<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>清风向阳</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="清风向阳">
<meta property="og:url" content="http://mjjde.github.io/index.html">
<meta property="og:site_name" content="清风向阳">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="清风向阳">
  
    <link rel="alternative" href="/atom.xml" title="清风向阳" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Joker Mei</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/FrontEndGuide">前端导航</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/luuman" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="#" title="weibo">weibo</a>
                            
                                <a class="fl google" target="_blank" href="#" title="google">google</a>
                            
                                <a class="fl twitter" target="_blank" href="#" title="twitter">twitter</a>
                            
                                <a class="fl linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/Android/" style="font-size: 17.5px;">Android</a> <a href="/tags/Android-IPC/" style="font-size: 10px;">Android-IPC</a> <a href="/tags/Binder/" style="font-size: 17.5px;">Binder</a> <a href="/tags/DiskLruCache/" style="font-size: 10px;">DiskLruCache</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/HTTP/" style="font-size: 20px;">HTTP</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Notification/" style="font-size: 10px;">Notification</a> <a href="/tags/RemoteView/" style="font-size: 10px;">RemoteView</a> <a href="/tags/Rxjava/" style="font-size: 15px;">Rxjava</a> <a href="/tags/ServiceManager/" style="font-size: 15px;">ServiceManager</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/volley/" style="font-size: 12.5px;">volley</a> <a href="/tags/widget/" style="font-size: 10px;">widget</a> <a href="/tags/事件/" style="font-size: 10px;">事件</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://luuman.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Joker Mei</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Joker Mei</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/FrontEndGuide">前端导航</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/luuman" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
                    
                        <a class="google" target="_blank" href="#" title="google">google</a>
                    
                        <a class="twitter" target="_blank" href="#" title="twitter">twitter</a>
                    
                        <a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-图解Http六HTTP首部" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/06/图解Http六HTTP首部/" class="article-date">
      <time datetime="2017-05-06T07:28:43.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/06/图解Http六HTTP首部/">图解Http六HTTP首部</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>HTTP协议的请求和响应报文必定包含HTTP首部，只是我们平时在使用Web的过程中感受不到它</p>
</blockquote>
<h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a><a href="#HTTP_u9996_u90E8_u5B57_u6BB5" title="HTTP首部字段"></a>HTTP首部字段</h3><p>HTTP首部字段是客户端和服务端的请求及相应报文中必不可缺的元素之一。它可以传递重要的信息。<br>HTTP首部的格式为<br>字段名:字段值<br>可以同时有多个字段值，使用逗号分开<br>字段名:字段值,字段值</p>
<h3 id="首部预览"><a href="#首部预览" class="headerlink" title="首部预览"></a><a href="#u9996_u90E8_u9884_u89C8" title="首部预览"></a>首部预览</h3><ol>
<li>常见首部字段<br><img src="http://jokero1o.github.io/images/blog_http_6-1.png" alt=""><br><img src="http://jokero1o.github.io/images/blog_http_6-2.png" alt=""><br><img src="http://jokero1o.github.io/images/blog_http_6-3.png" alt=""><br><img src="http://jokero1o.github.io/images/blog_http_6-4.png" alt=""><br><img src="http://jokero1o.github.io/images/blog_http_6-5.png" alt=""></li>
<li>非HTTP规定的首部字段<br>比如之前提到的Cookie，set-Cookie</li>
<li>End-to-end首部和Hop-by-hop首部<br>端到端首部(End-to-end)分在此类的首部将会作用到最后的接收目标。且必须保存在由缓存生成的响应中，另外规定必须被转发<br>逐跳首部(Hop-by-hop)分在此类别中的首部只对单次的转发有效。在HTTP/1.1和之后的版本需要加上Connection首部字段</li>
</ol>
<h3 id="HTTP-1-1通用首部字段"><a href="#HTTP-1-1通用首部字段" class="headerlink" title="HTTP/1.1通用首部字段"></a><a href="#HTTP/1-1_u901A_u7528_u9996_u90E8_u5B57_u6BB5" title="HTTP/1.1通用首部字段"></a>HTTP/1.1通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a><a href="#Cache-Control" title="Cache-Control"></a>Cache-Control</h4><p>该指令可以控制缓存的机制</p>
<h5 id="public"><a href="#public" class="headerlink" title="public"></a><a href="#public" title="public"></a>public</h5><p>表示其他的用户也可以适合该缓存</p>
<h5 id="private"><a href="#private" class="headerlink" title="private"></a><a href="#private" title="private"></a>private</h5><p>表示只提供给特定的用户使用的缓存，其他用户发过来请求，代理服务器不会返回缓存</p>
<h5 id="no-cache"><a href="#no-cache" class="headerlink" title="no-cache"></a><a href="#no-cache" title="no-cache"></a>no-cache</h5><p>该指令主要是防止从缓存服务器中返回了过期的资源<br>客户端发送的请求中包含该指令表示代理服务器不能返回缓存，强制要求返回源服务器中的资源<br>服务端响应中包含该指令表示代理服务器不能将缓存保存，代理服务器想源服务器请求缓存有效性也会直接返回无效，如果服务端的响应中的该字段没有具体的值，可以使用缓存。</p>
<h5 id="no-store"><a href="#no-store" class="headerlink" title="no-store"></a><a href="#no-store" title="no-store"></a>no-store</h5><p>该指令表示缓存不能在本地存储请求或者响应的任何部分</p>
<h5 id="s-maxage"><a href="#s-maxage" class="headerlink" title="s-maxage"></a><a href="#s-maxage" title="s-maxage"></a>s-maxage</h5><p>该指令是针对多用户使用的公共缓存服务器，对单个用户重复返回的服务器来说是无效的。使用该指令后Expires和max-age是无效的</p>
<h5 id="max-age"><a href="#max-age" class="headerlink" title="max-age"></a><a href="#max-age" title="max-age"></a>max-age</h5><p>该字段出现在客户端表示在max-age规定的时间内可以返回缓存的。<br>该字段出现在服务端表示在max-age规定的时间内不会对缓存的有效性确认。如果值是0，那么缓存服务器就会去源服务器请求。</p>
<h5 id="min-fresh"><a href="#min-fresh" class="headerlink" title="min-fresh"></a><a href="#min-fresh" title="min-fresh"></a>min-fresh</h5><p>该字段表示要求发起请求到缓存服务器返回缓存的时间(新鲜生命期)要小于指定的值</p>
<h5 id="max-stale"><a href="#max-stale" class="headerlink" title="max-stale"></a><a href="#max-stale" title="max-stale"></a>max-stale</h5><p>表示即使缓存资源过期了也会接收，如果有具体的值，那么过期了但是在该值内也接收</p>
<h5 id="only-if-cache"><a href="#only-if-cache" class="headerlink" title="only-if-cache"></a><a href="#only-if-cache" title="only-if-cache"></a>only-if-cache</h5><p>该指标表示客户端要求只有缓存服务器有缓存的情况下才会去返回，如果没有缓存，就返回504</p>
<h5 id="must-revalidate"><a href="#must-revalidate" class="headerlink" title="must-revalidate"></a><a href="#must-revalidate" title="must-revalidate"></a>must-revalidate</h5><p>该指令要求缓存服务器必须向源服务器确认即将返回的缓存的有效性，如果源服务器没有响应，则返回504，同是max-stale失效</p>
<h5 id="proxy-revalidate"><a href="#proxy-revalidate" class="headerlink" title="proxy-revalidate"></a><a href="#proxy-revalidate" title="proxy-revalidate"></a>proxy-revalidate</h5><p>该指令表示所以的缓存服务器接受到了带改指令的请求，都要向源服务器请求缓存的有效性</p>
<h5 id="no-transform"><a href="#no-transform" class="headerlink" title="no-transform"></a><a href="#no-transform" title="no-transform"></a>no-transform</h5><p>该指令表示缓存都不能改变请求或者响应的媒体类型</p>
<h5 id="cache-extension-token"><a href="#cache-extension-token" class="headerlink" title="cache-extension token"></a><a href="#cache-extension_token" title="cache-extension token"></a>cache-extension token</h5><p>该指令可以扩展Cache-Control的指令</p>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a><a href="#Connection" title="Connection"></a>Connection</h4><ul>
<li>控制不再转发给代理的首部字段</li>
<li>管理持久连接</li>
</ul>
<ol>
<li>控制不再转发给代理的首部字段<br>在客户端发送的请求或者服务端返回的响应使用该字段可以使该字段定义的字段不被转发给其他的代理服务器。Hop-by-hop</li>
<li>管理持久连接<br>HTTP/1.1默认是会持久连接的，使用Close值可以关闭连接，使用keep-alive可以保持连接</li>
</ol>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a><a href="#Date" title="Date"></a>Date</h4><p>该字段表示创建HTTP报文的创建时间</p>
<h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a><a href="#Transfer-Encoding" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>该字段表示传输是的报文采用什么编码</p>
<h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a><a href="#Upgrade" title="Upgrade"></a>Upgrade</h4><p>用于检测HTTP协议以及其他协议是否可以使用</p>
<h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a><a href="#Via" title="Via"></a>Via</h4><p>报文在经过代理或者网关是会追加via字段来追踪传输的路径</p>
<h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a><a href="#Warning" title="Warning"></a>Warning</h4><p>该首部通常会告知用户一些与缓存相关的问题的</p>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a><a href="#u8BF7_u6C42_u9996_u90E8_u5B57_u6BB5" title="请求首部字段"></a>请求首部字段</h3><p>请求首部字段是指客户端向服务端发送请求是所带的首部</p>
<h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a><a href="#Accept" title="Accept"></a>Accept</h4><p>该首部表面客户端可接受的媒体类型，且可以使用q来说明权重，服务端会根据权重来优先返回该媒体</p>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a><a href="#Accept-Charset" title="Accept-Charset"></a>Accept-Charset</h4><p>该首部用来告诉服务端客户端支持的字符集，可以使用q来说明权重</p>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a><a href="#Accept-Encoding" title="Accept-Encoding"></a>Accept-Encoding</h4><p>该首部用来告诉服务端客户端支持的编码及优先顺序</p>
<h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a><a href="#Accept-Language" title="Accept-Language"></a>Accept-Language</h4><p>该首部用来告诉服务端客户端所能支持的语言</p>
<h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a><a href="#Authorization" title="Authorization"></a>Authorization</h4><p>该首部是用来告诉服务端用户代理的认证的值</p>
<h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a><a href="#Expect" title="Expect"></a>Expect</h4><p>客户端使用该首部来告知服务端期望做出某些特定的行为</p>
<h4 id="From"><a href="#From" class="headerlink" title="From"></a><a href="#From" title="From"></a>From</h4><p>该首部用来告诉服务端使用用户代理的用户电子邮件地址</p>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a><a href="#Host" title="Host"></a>Host</h4><p>该首部可以告知服务端请求的资源所处的互联网主机名和端口号</p>
<h4 id="if-Match"><a href="#if-Match" class="headerlink" title="if-Match"></a><a href="#if-Match" title="if-Match"></a>if-Match</h4><p>该首部表示服务端只有在满足条件才可以返回，if-Match的值需要和ETag一致</p>
<h4 id="if-Modified-Since"><a href="#if-Modified-Since" class="headerlink" title="if-Modified-Since"></a><a href="#if-Modified-Since" title="if-Modified-Since"></a>if-Modified-Since</h4><p>该首部告知服务端如果资源更新时间晚于定义的值，则希望处理该请求，如果没有更新，就返回304</p>
<h4 id="if-None-Match"><a href="#if-None-Match" class="headerlink" title="if-None-Match"></a><a href="#if-None-Match" title="if-None-Match"></a>if-None-Match</h4><p>该首部表示服务端的资源ETag与定义的值不一致才处理请求</p>
<h4 id="if-Range"><a href="#if-Range" class="headerlink" title="if-Range"></a><a href="#if-Range" title="if-Range"></a>if-Range</h4><p>该首部告知服务端若指定的值ETag或者时间和请求资源的ETag或时间相一致的话则做范围请求处理</p>
<h4 id="if-Unmodified-Since"><a href="#if-Unmodified-Since" class="headerlink" title="if-Unmodified-Since"></a><a href="#if-Unmodified-Since" title="if-Unmodified-Since"></a>if-Unmodified-Since</h4><p>该首部和if-Modified-Since相反</p>
<h4 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a><a href="#Max-Forwards" title="Max-Forwards"></a>Max-Forwards</h4><p>该首部以十进制整数形式指定可经过的服务器个数，一种调试手段</p>
<h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a><a href="#Proxy-Authorization" title="Proxy-Authorization"></a>Proxy-Authorization</h4><p>该首部是用来当代理服务器发来认证质询时来告知服务器的认证信息</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a><a href="#Range" title="Range"></a>Range</h4><p>该首部表示范围请求的请求范围</p>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a><a href="#Referer" title="Referer"></a>Referer</h4><p>该首部告知服务端请求的原始资源的URI</p>
<h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a><a href="#TE" title="TE"></a>TE</h4><p>该首部告知服务端客户端能够处理响应的传输编码方式和优先级</p>
<h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a><a href="#User-Agent" title="User-Agent"></a>User-Agent</h4><p>该首部会简化创建请求的浏览器和用户代理名称等信息传达给服务端</p>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a><a href="#u54CD_u5E94_u9996_u90E8_u5B57_u6BB5" title="响应首部字段"></a>响应首部字段</h3><p>响应首部字段是有服务器想客户端发送响应式使用的首部字段</p>
<h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a><a href="#Accept-Ranges" title="Accept-Ranges"></a>Accept-Ranges</h4><p>该首部告知客户端服务端是否能处理传过来的范围请求，处理成功值为byte，无法处理为none</p>
<h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a><a href="#Age" title="Age"></a>Age</h4><p>该首部告知客户端服务端多久前创建了响应</p>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><a href="#ETag" title="ETag"></a>ETag</h4><p>该首部告知客户端实体标识</p>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a><a href="#Location" title="Location"></a>Location</h4><p>该首部告知客户端可能需要根据该值来再次请求资源</p>
<h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a><a href="#Proxy-Authenticate" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><p>该首部会把有代理服务器所要求的认证信息传给客户端</p>
<h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a><a href="#Retry-After" title="Retry-After"></a>Retry-After</h4><p>该首部告知客户端应该在多久之后再次发送请求</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a><a href="#Server" title="Server"></a>Server</h4><p>该首部告知客户端当前服务器上安装的HTTP服务器应用信息</p>
<h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a><a href="#Vary" title="Vary"></a>Vary</h4><p>该首部用来控制代理服务器返回缓存的条件</p>
<h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a><a href="#WWW-Authenticate" title="WWW-Authenticate"></a>WWW-Authenticate</h4><p>该首部用于HTTP访问认证</p>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a><a href="#u5B9E_u4F53_u9996_u90E8_u5B57_u6BB5" title="实体首部字段"></a>实体首部字段</h3><p>实体首部字段是包含请求和响应报文中实体部分使用的字段</p>
<h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a><a href="#Allow" title="Allow"></a>Allow</h4><p>该首部通知客户端能支持的Request-URI指定资源的所有HTTP方法，当服务器接收到不支持的HTTP请求方法，返回405</p>
<h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a><a href="#Content-Encoding" title="Content-Encoding"></a>Content-Encoding</h4><p>该首部告知客户端对实体的主体部分选用的内容编码格式</p>
<h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a><a href="#Content-Language" title="Content-Language"></a>Content-Language</h4><p>该首部告知客户端，实体主体使用的自然语言</p>
<h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a><a href="#Content-Length" title="Content-Length"></a>Content-Length</h4><p>该首部表示实体主体部分的大小</p>
<h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a><a href="#Content-Location" title="Content-Location"></a>Content-Location</h4><p>该首部给出报文主体部分的对应的URI，客户端可能会根据URI再次请求资源</p>
<h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a><a href="#Content-MD5" title="Content-MD5"></a>Content-MD5</h4><p>该首部值数一串MD5算法生成的值，目的是为了保证传输过程中实体数据的完整性</p>
<h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a><a href="#Content-Range" title="Content-Range"></a>Content-Range</h4><p>该首部是针对范围请求是响应使用的首部，表示响应实体的范围</p>
<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a><a href="#Content-Type" title="Content-Type"></a>Content-Type</h4><p>该首部表示对于的实体内对象的媒体类型</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><a href="#Expires" title="Expires"></a>Expires</h4><p>该首部会将资源失效的日期告诉给客户端</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a><a href="#Last-Modified" title="Last-Modified"></a>Last-Modified</h4><p>该首部会告知客户端资源最后修改的日期</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图解Http五与HTTP协作的Web服务器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/05/图解Http五与HTTP协作的Web服务器/" class="article-date">
      <time datetime="2017-05-05T07:28:43.000Z" itemprop="datePublished">2017-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/05/图解Http五与HTTP协作的Web服务器/">图解Http五与HTTP协作的Web服务器</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>一台服务器可以搭载多个不同独立域名的Web网站，也可以作为通信路径上的中转服务器提升传输效率</p>
</blockquote>
<h3 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a><a href="#u7528_u5355_u53F0_u865A_u62DF_u4E3B_u673A_u5B9E_u73B0_u591A_u4E2A_u57DF_u540D" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h3><p>即使物理层面上只有一台服务端，但是使用了虚拟主机的功能就可以假象成多台服务器，提供给多个客户服务，可以以每个客户所持有域名来运行各自不同的网站</p>
<h3 id="通信数据转发程序：代理，网关，隧道"><a href="#通信数据转发程序：代理，网关，隧道" class="headerlink" title="通信数据转发程序：代理，网关，隧道"></a><a href="#u901A_u4FE1_u6570_u636E_u8F6C_u53D1_u7A0B_u5E8F_uFF1A_u4EE3_u7406_uFF0C_u7F51_u5173_uFF0C_u96A7_u9053" title="通信数据转发程序：代理，网关，隧道"></a>通信数据转发程序：代理，网关，隧道</h3><p>HTTP通信数，不止是服务端和客户端，还有一些用于通信数据转发的应用程序，如代理，网关，隧道。</p>
<ol>
<li>代理<br>代理是一种具备转发功能的应用程序，它扮演了服务器和客户端之间的“中间人”的角色，它可以将客户端发出的请求转发给服务端，也可以将服务端的响应转发给客户端。</li>
<li>网关<br>网关是转发其他服务器通信数据的服务器，接收来自客户端发来的请求。就想自己拥有资源一样的对请求进行处理。有时客户端不会察觉自己是在与网关通信</li>
<li>隧道<br>隧道是在相隔很远的服务器和客户端之间进行中转，并保持双方连接的应用程序</li>
</ol>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a><a href="#u4EE3_u7406" title="代理"></a>代理</h3><p>代理服务器的基本行为就是接受客户端发送过来的请求转发给其他的服务器，代理不改变请求的URI，会直接将请求转发给持有资源的服务器，<br>持有资源的服务器叫做源服务器，从源服务器返回的响应信息经过代理服务器转发给客户端</p>
<p>在HTTP通信过程中可以级联多个代理服务器，请求和响应的转发会经过向锁链一样连接的代理服务器，转发是需要附加Via首部字段。</p>
<p>使用代理服务器的理由：利用缓存技术较少网络带宽的流量，组织内部针对特定网站的访问控制，以获得访问日志为主要目的，等</p>
<p>代理的使用方法可以分为两类。一种是是否使用缓存，另一种是是否修改报文</p>
<ol>
<li>缓存代理服务器<br>代理在转发响应时，缓存代理会将资源的副本保存在代理服务器上，当再次接收到相同请求时，可以不用从源服务器获取资源，而是将之前的缓存的资源直接返回</li>
<li>透明代理服务器<br>转发请求或响应时不对报文做任何的加工的代理类型称为透明代理，反之为非透明代理</li>
</ol>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a><a href="#u7F51_u5173" title="网关"></a>网关</h3><p>网关的工作机制和代理相似，而网关能使通信路上的服务器提供非HTTP协议服务。<br>利用网关可以提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。</p>
<h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a><a href="#u96A7_u9053" title="隧道"></a>隧道</h3><p>隧道可以按要求建立起与其他服务器的通信线路。可以使用SSL等加密手段进行通信。隧道是保证服务端和客户端之间进行安全的通信。</p>
<h3 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a><a href="#u4FDD_u5B58_u8D44_u6E90_u7684_u7F13_u5B58" title="保存资源的缓存"></a>保存资源的缓存</h3><p>缓存是指代理服务端或者本地客户端磁盘保存的资源副本，理由缓存可以减少对源服务器的访问，减少通信流量和通信时间。</p>
<h4 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a><a href="#u7F13_u5B58_u7684_u6709_u6548_u671F_u9650" title="缓存的有效期限"></a>缓存的有效期限</h4><p>即使服务器内有缓存，也不能保证每次都是返回对同资源的请求，因为被缓存的资源有效性问题。<br>即使服务器上有缓存，也会因为客户端的要求，缓存的有效期问题，向源服务器确认自由的额有效性。判断失败则会在源服务器上获取新的资源。</p>
<h4 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a><a href="#u5BA2_u6237_u7AEF_u7684_u7F13_u5B58" title="客户端的缓存"></a>客户端的缓存</h4><p>缓存不仅可以缓存在服务器里，也可以缓存在本地浏览器中，如果缓存是有效的，那么就不需要再向服务器发送请求了。直接返回本地的缓存资源。<br>当本地缓存过期是，还是会向源服务器发送请求，以获得最新的资源。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图解Http四返回结果的HTTP状态码" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/04/图解Http四返回结果的HTTP状态码/" class="article-date">
      <time datetime="2017-05-04T07:28:43.000Z" itemprop="datePublished">2017-05-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/04/图解Http四返回结果的HTTP状态码/">图解Http四返回结果的HTTP状态码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>HTTP状态码负责表示客户端HTTP请求的返回结果，标记服务器端的处理是否正常、通知出现的错误等工作</p>
</blockquote>
<h3 id="状态码告知从服务端返回的请求结果"><a href="#状态码告知从服务端返回的请求结果" class="headerlink" title="状态码告知从服务端返回的请求结果"></a><a href="#u72B6_u6001_u7801_u544A_u77E5_u4ECE_u670D_u52A1_u7AEF_u8FD4_u56DE_u7684_u8BF7_u6C42_u7ED3_u679C" title="状态码告知从服务端返回的请求结果"></a>状态码告知从服务端返回的请求结果</h3><p>状态码是用来告知客户端发送给服务端的请求的处理情况，借助状态码可以知道服务端请求是正常的还是出现了错误</p>
<p><img src="http://jokero1o.github.io/images/blog_http_4-1.png" alt=""></p>
<h3 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a><a href="#2XX_u6210_u529F" title="2XX成功"></a>2XX成功</h3><p>2XX的响应结果表明请求被正常处理了。</p>
<ol>
<li>204 No Content<br>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。<br>一般在只需要从客户端向服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</li>
<li>206 Partial Content<br>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由 Content-Range 指定范围的实体内容</li>
</ol>
<h3 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a><a href="#3XX_u91CD_u5B9A_u5411" title="3XX重定向"></a>3XX重定向</h3><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<ol>
<li>301 Moved Permanently<br>永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI</li>
<li>302 Found<br>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的 URI访问</li>
<li>303 See Other<br>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>
<li>304 Not Modified<br>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况</li>
<li>307 Temporary Redirect<br>临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变成GET，但实际使用时大家并不遵守。</li>
</ol>
<h3 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a><a href="#4XX_u5BA2_u6237_u7AEF_u9519_u8BEF" title="4XX客户端错误"></a>4XX客户端错误</h3><p>4XX的响应结果表明客户端是发生错误的原因所在。</p>
<ol>
<li>400 Bad Request<br>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再发送请求。</li>
<li>401 Unauthorized<br>该状态码表示发送的请求需要有通过HTTP认证(BASIC 认证、 DIGEST 认证)的认证信息</li>
<li>403 Forbidden<br>该状态码表明对请求资源的 问被服务器拒绝了</li>
<li>404 Not Found<br>该状态码表明服务器上无法找到请求的资源</li>
</ol>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a><a href="#5XX__u670D_u52A1_u5668_u9519_u8BEF" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>5XX的响应结果表明服务器本身发生错误</p>
<ol>
<li>500 Internal Server Error<br>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的错误。</li>
<li>503 Service Unavailable<br>该状态码表明服务器暂时处于超负荷或正在进行停机维，现在无法处理请求</li>
</ol>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图解Http三HTTP报文内的HTTP信息" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/29/图解Http三HTTP报文内的HTTP信息/" class="article-date">
      <time datetime="2017-04-29T07:28:43.000Z" itemprop="datePublished">2017-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/29/图解Http三HTTP报文内的HTTP信息/">图解Http三HTTP报文内的HTTP信息</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>HTTP通信过程包括客户端发往服务端的请求以及从服务端返回客户端的响应</p>
</blockquote>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a><a href="#HTTP_u62A5_u6587" title="HTTP报文"></a>HTTP报文</h3><p>客户端发出的HTTP报文叫做请求报文，服务端返回的HTTP报文叫响应报文，报文通常包括两个部分，报文首部和报文主体，报文主体不一定存在。报文首部和报文主体以首次出现的换行符来划分(CR+LF)</p>
<h3 id="HTTP报文的结构"><a href="#HTTP报文的结构" class="headerlink" title="HTTP报文的结构"></a><a href="#HTTP_u62A5_u6587_u7684_u7ED3_u6784" title="HTTP报文的结构"></a>HTTP报文的结构</h3><p><img src="http://jokero1o.github.io/images/blog_http_3-1.png" alt=""></p>
<ol>
<li>请求行:包含请求的方法和使用的HTTP版本号</li>
<li>响应行:包含响应的HTTP版本号和状态码原因短语</li>
<li>首部字段:包含请求和响应的属性和条件的各类首部，一般有四种首部，通用首部，请求首部，响应首部，主体首部</li>
<li>其他: 可能包含HTTP的RFC里未定义的首部</li>
</ol>
<h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a><a href="#u7F16_u7801_u63D0_u5347_u4F20_u8F93_u901F_u7387" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP在传输数据时，可以按照数据原貌直接传输，也可以使用编码来提升传输的速率。编码是由计算机处理的，所以这是一种资源换性能的手段。</p>
<h4 id="报文主体和实体主体的区别"><a href="#报文主体和实体主体的区别" class="headerlink" title="报文主体和实体主体的区别"></a><a href="#u62A5_u6587_u4E3B_u4F53_u548C_u5B9E_u4F53_u4E3B_u4F53_u7684_u533A_u522B" title="报文主体和实体主体的区别"></a>报文主体和实体主体的区别</h4><ol>
<li>报文是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输</li>
<li>实体是作为请求或者响应的有效载荷数据被传输，其内容由实体首部和实体主体组成<br>一般情况下报文主体是等于实体主体的，但是经过编码后的传输的实体主体发生变化，而导致传输中的报文主体发生变化，这样变化后的报文主体和为编码的主体是不等的。</li>
</ol>
<h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a><a href="#u538B_u7F29_u4F20_u8F93_u7684_u5185_u5BB9_u7F16_u7801" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码是指明应用在实体上的编码格式，这种编码格式会保持实体主体原样压缩。服务端接收到内容编码的实体进行解压<br>常用的内容编码有：gzip(GNU zip)，compress(NUIX 系统的标准压缩),deflate(zlib),identity(不进行压缩)</p>
<h4 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a><a href="#u5206_u5272_u53D1_u9001_u7684_u5206_u5757_u4F20_u8F93_u7F16_u7801" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h4><p>HTTP传输在未完成时，浏览器是无法显示内容的，那么如果HTTP的传输是一块一块的传输的话，浏览器就会逐步的展示<br>这样将数据实体分割成一块一块的功能称为分块传输编码</p>
<h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a><a href="#u53D1_u9001_u591A_u79CD_u6570_u636E_u7684_u591A_u90E8_u5206_u5BF9_u8C61_u96C6_u5408" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP协议中采用了多部分对象集合，发送一份报文主体内容内可含有多类型实体，通常是在数据上传图片文件文本是使用。</p>
<ol>
<li>multipart/form-data<br>在web表单文件上传是使用</li>
<li>multipart/byteranges<br>响应报文包括多个范围的内容使用<br>在HTTP报文中使用多部分对象集合是需要加入Content-type字段。<br>使用boundary来分割每个对象块，多部分对象起始位置使用–boundary来表明，接着每个部分都要使用–boundary来分开，最后使用–boundary–来结束<br>每个部分都可以是有首部对象，每个部分都可以嵌套子部分对象</li>
</ol>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a><a href="#u83B7_u53D6_u90E8_u5206_u5185_u5BB9_u7684_u8303_u56F4_u8BF7_u6C42" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>下载大文件时在网络不稳定的时候容易失败，失败后就需要重新下载，为了解决这个为题，需要一种可以恢复之前下载的机制，就是好指定下载的范围。这就是范围请求</p>
<p>执行范围请求时需要加入首部字段Range来指定资源的byte范围。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">Range:</span> <span class="keyword">byte</span>= <span class="number">10000</span><span class="number">-20000</span></div><div class="line"><span class="string">Range:</span> <span class="keyword">byte</span>= <span class="number">10000</span>-</div><div class="line"><span class="string">Range:</span> bytes=<span class="number">-3000</span>, <span class="number">5000</span><span class="number">-7000</span></div></pre></td></tr></table></figure>
<p>针对范围请求的正确返回的状态码是206，如果无法响应范围资源就返回200 并返回所有的主体。</p>
<h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a><a href="#u5185_u5BB9_u534F_u5546_u8FD4_u56DE_u6700_u5408_u9002_u7684_u5185_u5BB9" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商是指服务端与客户端就响应的资源内容进行交涉，返回给客户端最为适合的内容</p>
<ol>
<li><p>服务端驱动协商<br>客户端提供首部字段给服务端，服务端来进行内容协商<br>如 Accept，Accept-Charset，Accept-Encoding，Accept-Language，Content-Language</p>
</li>
<li><p>客户端驱动协商<br>有客户端负责内容协商，可以有某个按钮或者js来控制内容</p>
</li>
<li><p>透明协商<br>服务端驱动和客户端驱动的结合体，由服务端和客户端各自进行协商的一种方式</p>
</li>
</ol>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图解Http一了解Web及网络服务" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/28/图解Http一了解Web及网络服务/" class="article-date">
      <time datetime="2017-04-28T07:28:43.000Z" itemprop="datePublished">2017-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/28/图解Http一了解Web及网络服务/">图解Http一了解Web及网络服务</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>本章所讲解的内容是：Web是建立在什么技术上，以及HTTP的协议是如何诞生的。</p>
<h3 id="使用HTTP协议访问Web"><a href="#使用HTTP协议访问Web" class="headerlink" title="使用HTTP协议访问Web"></a><a href="#u4F7F_u7528HTTP_u534F_u8BAE_u8BBF_u95EEWeb" title="使用HTTP协议访问Web"></a>使用HTTP协议访问Web</h3><ol>
<li>根据Web浏览器地址栏中的指定的URL，Web浏览器从Web服务端获取文件资源等信息，从而显示出Web页面。</li>
<li>Web是使用一种名为HTTP的协议作为规范，完成客户端到服务端的一系列动作流程。</li>
<li>协议是指规则的约定，所以Web是建立在HTTP协议上的通信的</li>
</ol>
</blockquote>
<h3 id="HTTP诞生"><a href="#HTTP诞生" class="headerlink" title="HTTP诞生"></a><a href="#HTTP_u8BDE_u751F" title="HTTP诞生"></a>HTTP诞生</h3><ol>
<li>1989年3月。这是互联网的黎明期，HTTP诞生</li>
<li>1990年11月，CERN成功研发世界第一台Web服务器和Web浏览器</li>
<li>HTTP 于 1990 年问世。那时的 HTTP 并 有作为正式的标准被建立。 现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被 为 HTTP/0.9</li>
<li>HTTP 正式作为标准被 是在 1996 年的 5 ，版本被 名为 HTTP/1.0，并记 于 RFC1945。 说是初 标准，但该协议标准 今仍 被 使用在服务器端。</li>
<li>1997 年 1 的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初 的标准是 RFC2068，之后发 的修 版 RFC2616 就是当前的最新版本。</li>
</ol>
<h3 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP/IP"></a><a href="#u7F51_u7EDC_u57FA_u7840TCP/IP" title="网络基础TCP/IP"></a>网络基础TCP/IP</h3><p>我们通常使用的网络是在TCP/IP协议族的基础上进行的，而HTTP是他内部的一个子集。</p>
<h4 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a><a href="#TCP/IP_u534F_u8BAE_u65CF" title="TCP/IP协议族"></a>TCP/IP协议族</h4><p>把与互联网相关联的协议集合起来总称TCP/IP。也有说法任务TCP/IP是指TCP和IP两种协议，或是在IP协议的通信过程中使用到的协议族的统称。</p>
<h4 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a><a href="#TCP/IP_u7684_u5206_u5C42_u7BA1_u7406" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h4><p>TCP/IP分为应用层,传输层，网络层,数据链路层。</p>
<h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><a href="#u5E94_u7528_u5C42" title="应用层"></a>应用层</h5><p>应用层决定了向用户提供应用服务通信的活动，比如DNS,FTP,HTTP等</p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><a href="#u4F20_u8F93_u5C42" title="传输层"></a>传输层</h5><p>传输层对上层应用层，提供处于网络连接中的两太计算机之间的数据传输，在传输层有两个不同的协议，一个是TCP一个是UDP</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><a href="#u7F51_u7EDC_u5C42" title="网络层"></a>网络层</h5><p>网络层是用来处理网络上流动的数据包。数据包是网络传输的最小单位，该层规定了通过怎么样的路径（传输路径）来到达对方的计算机。并把数据包传送给对方。<br>在对方计算机之间通过多台计算机或者网络设备进行传输时，该层提供了在众多选项内的一条传输路线。</p>
<h5 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a><a href="#u94FE_u8DEF_u5C42" title="链路层"></a>链路层</h5><p>用来处理连接网络的硬件部分。包括控制系统，硬件的驱动，网卡，光纤等可见的硬件设备，硬件上的范畴都是属于链路层的作用范围。</p>
<h4 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP/IP通信传输流"></a><a href="#TCP/IP_u901A_u4FE1_u4F20_u8F93_u6D41" title="TCP/IP通信传输流"></a>TCP/IP通信传输流</h4><p><img src="http://jokero1o.github.io/images/blog_http_1.png" alt=""><br>web客户端发送一次请求，使用HTTP协议，经过传输层，为了传输方便TCP协议将数据进行分割，并在各个报文上打上标记序号和端口号发送给网络层，网络层接收到一个个报文后增加作为通信目标的MAC地址后转发给 链路层，这样客户端侧的网络请求就发送完毕了。<br>服务器接受端在链路层接受到了数据再按顺序往上层发送，一直到应用层，当到达应用层后，服务端算是收到了一次HTTP网络请求。<br><img src="http://jokero1o.github.io/images/blog_http_2.png" alt=""><br>发送端每经过一层都必定会打上一个该层的首部信息，反之，接收端都会在每个层级上把对于的首部消去</p>
<h3 id="与HTTP关系密切的协议：IP，TCP-DNS"><a href="#与HTTP关系密切的协议：IP，TCP-DNS" class="headerlink" title="与HTTP关系密切的协议：IP，TCP,DNS"></a><a href="#u4E0EHTTP_u5173_u7CFB_u5BC6_u5207_u7684_u534F_u8BAE_uFF1AIP_uFF0CTCP_2CDNS" title="与HTTP关系密切的协议：IP，TCP,DNS"></a>与HTTP关系密切的协议：IP，TCP,DNS</h3><h4 id="负责传输的IP协议"><a href="#负责传输的IP协议" class="headerlink" title="负责传输的IP协议"></a><a href="#u8D1F_u8D23_u4F20_u8F93_u7684IP_u534F_u8BAE" title="负责传输的IP协议"></a>负责传输的IP协议</h4><p>IP协议的作用是要把数据传输给接收端，而要保证数据能够正确的传输到对方那里是需要具备各类条件的，其中两个重要的条件是IP地址和MAC地址<br>IP地址是指名了节点被分配的地址，MAC地址是指网卡所属的固定地址，IP地址可变，MAC地址一般不会变。</p>
<h5 id="使用ARP协议凭借MAC地址进行通信"><a href="#使用ARP协议凭借MAC地址进行通信" class="headerlink" title="使用ARP协议凭借MAC地址进行通信"></a><a href="#u4F7F_u7528ARP_u534F_u8BAE_u51ED_u501FMAC_u5730_u5740_u8FDB_u884C_u901A_u4FE1" title="使用ARP协议凭借MAC地址进行通信"></a>使用ARP协议凭借MAC地址进行通信</h5><p>IP间的通信依赖MAC地址，但是IP通信经常需要计算机或者网络设备来中转，这个时候利用计算机或网络设备的MAC地址来查询到下一个中转目标。只时候我们需要使用ARP协议来根据通信方的IP来查询对应的MAC地址。</p>
<h4 id="确保可靠性的TCP"><a href="#确保可靠性的TCP" class="headerlink" title="确保可靠性的TCP"></a><a href="#u786E_u4FDD_u53EF_u9760_u6027_u7684TCP" title="确保可靠性的TCP"></a>确保可靠性的TCP</h4><p>TCP协议提供可靠的字节流服务，字节流服务是指将大块的数据包分割成小块的报文的数据包进行管理，可靠是指能将将数据准确可靠的传输给对方。</p>
<h5 id="确保数据的可靠性"><a href="#确保数据的可靠性" class="headerlink" title="确保数据的可靠性"></a><a href="#u786E_u4FDD_u6570_u636E_u7684_u53EF_u9760_u6027" title="确保数据的可靠性"></a>确保数据的可靠性</h5><p>TCP会进行三次握手来确保数据传输的可靠性。发送端首先会发送一次标有SYN的数据包，服务端接受到后发送一个标记SYN/ACK的数据包，发送端再发送一个标记ACK的数据包</p>
<h5 id="负责域名解析的DNS服务"><a href="#负责域名解析的DNS服务" class="headerlink" title="负责域名解析的DNS服务"></a><a href="#u8D1F_u8D23_u57DF_u540D_u89E3_u6790_u7684DNS_u670D_u52A1" title="负责域名解析的DNS服务"></a>负责域名解析的DNS服务</h5><p>DNS和HTTP协议一样是属于应用层的协议，DNS提供域名查找IP地址，IP地址反查域名。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图解Http二简单的HTTP协议" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/28/图解Http二简单的HTTP协议/" class="article-date">
      <time datetime="2017-04-28T07:28:43.000Z" itemprop="datePublished">2017-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/28/图解Http二简单的HTTP协议/">图解Http二简单的HTTP协议</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>针对HTTP协议结构进行讲解，主要使用HTTP/1.1版本</p>
</blockquote>
<h3 id="HTTP协议用于客户端和服务端之间的通信"><a href="#HTTP协议用于客户端和服务端之间的通信" class="headerlink" title="HTTP协议用于客户端和服务端之间的通信"></a><a href="#HTTP_u534F_u8BAE_u7528_u4E8E_u5BA2_u6237_u7AEF_u548C_u670D_u52A1_u7AEF_u4E4B_u95F4_u7684_u901A_u4FE1" title="HTTP协议用于客户端和服务端之间的通信"></a>HTTP协议用于客户端和服务端之间的通信</h3><p>两台计算机直接使用HTTP协议通信时，必定会有一端为客户端，一段为服务端。存在角色相互交换的情况，但是对于一次HTTP通信，必定会有一个是客户端，一个是服务端。</p>
<h3 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a><a href="#u901A_u8FC7_u8BF7_u6C42_u548C_u54CD_u5E94_u7684_u4EA4_u6362_u8FBE_u6210_u901A_u4FE1" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h3><p>HTTP的通信必定是从客户端发起的，服务端在没有接收到请求时是不会发送通信的。<br>客户端请求报文的具体内容是</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">第一行:请求方法<span class="comment">(get/post等等)</span> 请求URI<span class="comment">(/index.html)</span> 协议版本<span class="comment">(HTTP/1.1)</span></div><div class="line">第二行:可选首部字段<span class="comment">(Host/Connection)</span></div><div class="line">第三行:</div><div class="line">第四行:内容实体</div></pre></td></tr></table></figure>
<p>服务端响应报文的具体内容是</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">第一行:协议版本(HTTP/1.1) 状态码(200/404) 原因短语(OK)</span></div><div class="line"><span class="section">第二行:创建响应日期时间</span></div><div class="line"><span class="section">第三行:首部字段(Content-Type/Content-Length)</span></div><div class="line"><span class="section">第四行:</span></div><div class="line"><span class="section">第五行:实体内容</span></div></pre></td></tr></table></figure>
<h3 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a><a href="#HTTP_u662F_u4E0D_u4FDD_u5B58_u72B6_u6001_u7684_u534F_u8BAE" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h3><p>HTTP是具备保持状态的，不会对上次的请求进行持久化处理，HTTP请求是无状态的</p>
<h3 id="请求URI定位资源"><a href="#请求URI定位资源" class="headerlink" title="请求URI定位资源"></a><a href="#u8BF7_u6C42URI_u5B9A_u4F4D_u8D44_u6E90" title="请求URI定位资源"></a>请求URI定位资源</h3><p>HTTP使用URI定位在互联网上的资源，可以有多种方式来表示。</p>
<ol>
<li>URI为完整的请求URI</li>
<li>在首部字段Host写明网络域名或者IP地址</li>
</ol>
<h3 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a><a href="#u544A_u77E5_u670D_u52A1_u5668_u610F_u56FE_u7684HTTP_u65B9_u6CD5" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h3><ol>
<li>GET请求<br>GET方法是用来访问获取已经被URI表示的资源。</li>
<li>POST请求<br>POST请求是用来服务端发送实体主体。并不是像GET请求一样获取服务端的资源</li>
<li>PUT请求<br>PUT请求主要是用来给服务端发送文件，请求的实体是文件的内容，将该文件保存到请求的URI指定的位置</li>
<li>HEAD请求<br>HEAD请求与GET类似，但是并不是去获取URI知道的资源，而是确认资源是否存在有效</li>
<li>DELETE请求<br>DELETE请求是用来删除URI指定的资源</li>
<li>OPTIONS请求<br>OPTIONS请求是用来获取URI指定资源支持的请求方法</li>
<li>TRACE请求<br>TRACE请求是用来追踪一个请求发送之后是如何处理的</li>
<li>CONNECT请求<br>CONNECT请求主要是在与代理服务器通信时建立隧道。实现用隧道协议进行TCP通信</li>
</ol>
<h3 id="使用方法下达命令"><a href="#使用方法下达命令" class="headerlink" title="使用方法下达命令"></a><a href="#u4F7F_u7528_u65B9_u6CD5_u4E0B_u8FBE_u547D_u4EE4" title="使用方法下达命令"></a>使用方法下达命令</h3><p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。<br><img src="http://jokero1o.github.io/images/blog_http_2-1.png" alt=""></p>
<h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a><a href="#u6301_u4E45_u8FDE_u63A5_u8282_u7701_u901A_u4FE1_u91CF" title="持久连接节省通信量"></a>持久连接节省通信量</h3><p>HTTP协议在初始版本中是每请求一次都会创建一次连接，请求完成后就会断开。<br>这样在一定场景下不是很适合的。比如访问一个有大量图片的HTML页面，这样的话会有很多的连接断开无用动作，会耗费资源。</p>
<h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a><a href="#u6301_u4E45_u8FDE_u63A5" title="持久连接"></a>持久连接</h4><p>为了解决上面的问题HTTP/1.1和部分1.0采用持久连。持久连接的通信在双方没有明确要断开是，保持连接。<br>持久连接的好处在于可以减少TCP连接的持续建立和断开造成的额外开销，减轻的服务端的压力也减少客户端的资源开销。</p>
<h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a><a href="#u7BA1_u7EBF_u5316" title="管线化"></a>管线化</h4><p>持久连接就为管线化创造了条件，管线话是可以在不需要等待上次请求返回会在发送请求，这样就可以并行的去处理请求。</p>
<h3 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a><a href="#u4F7F_u7528Cookie_u7684_u72B6_u6001_u7BA1_u7406" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h3><p>HTTP是无状态的，所以无法根据上次请求的状态而改变或控制本次的请求。比如上次请求是登录请求，那么这次的请求是要根据是否登录成功来决定这次的返回，于是就引入了Cookie技术<br>服务端在接收到一个没有请求后生成一个Cookie值放在首部set-Cookie字段中，客户端接到了服务端的返回，在下次的请求的首部加入cookie字段填入服务端传来的cookie值，这样就知道是那次请求了。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android-Binder技术之ServiceManager获取" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/Android-Binder技术之ServiceManager获取/" class="article-date">
      <time datetime="2017-04-26T07:27:19.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/Android-Binder技术之ServiceManager获取/">Android-Binder技术之ServiceManager获取</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>既然ServiceManager已经启动了，那么就可以被获取了，获取的方法是defaultServiceManager(),注意这个方法返回的并不是ServiceManager进程，而是一个用C写在底层的IServiceManager对象。那么服务端需要获取ServiceManager来注册对象，也就是通过操作IServiceManager对象进行的，同样客户端需要获取ServiceManager注册过的Service，也是通过操作IServiceManager来进行的。接下来我们就来分析一下defaultServiceManager()方法。</p>
</blockquote>
<h2 id="一-获取过程"><a href="#一-获取过程" class="headerlink" title="一.获取过程"></a><a href="#u4E00-_u83B7_u53D6_u8FC7_u7A0B" title="一.获取过程"></a>一.获取过程</h2><p>获取ServiceManager的方法是defaultServiceManager,我们来看下源码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="keyword">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        AutoMutex _l(gDefaultServiceManagerLock);</div><div class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="keyword">NULL</span>) &#123;</div><div class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</div><div class="line">                ProcessState::self()-&gt;getContextObject(<span class="keyword">NULL</span>));</div><div class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="keyword">NULL</span>)</div><div class="line">                sleep(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> gDefaultServiceManager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就像我们上面说的一样，返回的是一个IServiceManager对象。这个对象采用的是单例模式，第一次创建之后的获取都是直接返回。</p>
<h3 id="ProcessState-self"><a href="#ProcessState-self" class="headerlink" title="ProcessState::self()"></a><a href="#ProcessState_3A_3Aself_28_29" title="ProcessState::self()"></a>ProcessState::self()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sp&lt;ProcessState&gt; ProcessState::self()</div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(gProcessMutex);</div><div class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> gProcess;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//实例化ProcessState 【见小节2.2】</span></div><div class="line">    gProcess = <span class="keyword">new</span> ProcessState;</div><div class="line">    <span class="keyword">return</span> gProcess;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法返回的是个ProcessState对象，我们看到这个依然是个单例模式。</p>
<h4 id="ProcessState初始化"><a href="#ProcessState初始化" class="headerlink" title="ProcessState初始化"></a><a href="#ProcessState_u521D_u59CB_u5316" title="ProcessState初始化"></a>ProcessState初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ProcessState::ProcessState()</div><div class="line">    : mDriverFD(open_driver()) <span class="comment">// 打开Binder驱动</span></div><div class="line">    , mVMStart(MAP_FAILED)</div><div class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</div><div class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</div><div class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</div><div class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</div><div class="line">    , mManagesContexts(<span class="literal">false</span>)</div><div class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</div><div class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</div><div class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</div><div class="line">    , mThreadPoolSeq(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//采用内存映射函数mmap，给binder分配一块虚拟地址空间,用来接收事务</span></div><div class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</div><div class="line">            close(mDriverFD); <span class="comment">//没有足够空间分配给/dev/binder,则关闭驱动</span></div><div class="line">            mDriverFD = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>打开binder驱动获取文件句柄赋值给mDriverFD</li>
<li>调用mmap创建内存映射空间</li>
</ol>
<h4 id="ProcessState-open-driver"><a href="#ProcessState-open-driver" class="headerlink" title="ProcessState::open_driver()"></a><a href="#ProcessState_3A_3Aopen_driver_28_29" title="ProcessState::open_driver()"></a>ProcessState::open_driver()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 打开/dev/binder设备，建立与内核的Binder驱动的交互通道</span></div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</div><div class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</div><div class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</div><div class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</div><div class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</div><div class="line">            close(fd);</div><div class="line">            fd = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</div><div class="line">            close(fd);</div><div class="line">            fd = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</div><div class="line"></div><div class="line">        <span class="comment">// 通过ioctl设置binder驱动，能支持的最大线程数</span></div><div class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</div><div class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ALOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>调用binder_open函数打开binder驱动，这个我们在上篇文章已经介绍过了。</li>
<li>检查binder驱动版本号</li>
<li>调用binder_ioctl设置该进程的最大线程数<br>我们这里调用的open(“/dev/binder”, O_RDWR)和上篇文章介绍的不是同一个，上面文章是在ServiceManager进程里打开的驱动文件，而这次是调用defaultServiceManager进程里调用的。</li>
</ol>
<h4 id="ioctl-fd-BINDER-SET-MAX-THREADS-amp-maxThreads"><a href="#ioctl-fd-BINDER-SET-MAX-THREADS-amp-maxThreads" class="headerlink" title="ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads)"></a><a href="#ioctl_28fd_2C_BINDER_SET_MAX_THREADS_2C__26amp_3BmaxThreads_29" title="ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads)"></a>ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> ret;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line"><span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line"></div><div class="line">ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></div><div class="line">thread = binder_get_thread(proc);</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">switch</span> (cmd) &#123;</div><div class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS:</div><div class="line">        <span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">...</div><div class="line">&#125;</div><div class="line">ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">...</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是将最大线程数目从用户空间拷贝到内核空间，进而赋值给binder_proc-&gt;max_threads。</p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a><a href="#mmap" title="mmap"></a>mmap</h4><p>这个知识点我们已经在上篇文章介绍过，这里就不去介绍了。</p>
<p>到此我们已经分析完ProcessState::self()方法，这个方法主要是打开驱动文件，并且设置当前进程的最大线程数。</p>
<h3 id="ProcessState-getContextObject"><a href="#ProcessState-getContextObject" class="headerlink" title="ProcessState::getContextObject()"></a><a href="#ProcessState_3A_3AgetContextObject_28_29" title="ProcessState::getContextObject()"></a>ProcessState::getContextObject()</h3><p>sp <ibinder>ProcessState::getContextObject(const sp<ibinder>&amp; caller)<br>{<br>return getStrongProxyForHandle(0);<br>}<br>这里的0带表的是ServiceManager的句柄</ibinder></ibinder></p>
<h4 id="ProcessState-getStrongProxyForHandle"><a href="#ProcessState-getStrongProxyForHandle" class="headerlink" title="ProcessState::getStrongProxyForHandle()"></a><a href="#ProcessState_3A_3AgetStrongProxyForHandle_28_29" title="ProcessState::getStrongProxyForHandle()"></a>ProcessState::getStrongProxyForHandle()</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">sp&lt;IBinder&gt; ProcessState<span class="type">::getStrongProxyForHandle</span>(int32_t <span class="keyword">handle</span>)</div><div class="line">&#123;</div><div class="line">    sp&lt;IBinder&gt; result;</div><div class="line"></div><div class="line">    AutoMutex _l(mLock);</div><div class="line"></div><div class="line">    <span class="comment">// 在矢量数组mHandleToObject中查找"句柄值为handle的handle_entry对象"；</span></div><div class="line">    <span class="comment">// 找到的话，则直接返回；找不到的话，则新建handle对应的handle_entry，并将其添加到mHandleToObject中。</span></div><div class="line">    handle_entry* e = lookupHandleLocked(<span class="keyword">handle</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e != <span class="built_in">NULL</span>) &#123;</div><div class="line">        IBinder* b = e-&gt;binder;</div><div class="line">        <span class="keyword">if</span> (b == <span class="built_in">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</div><div class="line">            <span class="comment">// 当handle==0(即是Service Manager的句柄)时，尝试去ping Binder驱动。</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">handle</span> == <span class="number">0</span>) &#123;</div><div class="line">                Parcel <span class="built_in">data</span>;</div><div class="line">                status_t status = IPCThreadState<span class="type">::self</span>()-&gt;transact(</div><div class="line">                        <span class="number">0</span>, IBinder<span class="type">::PING_TRANSACTION</span>, <span class="built_in">data</span>, <span class="built_in">NULL</span>, <span class="number">0</span>);</div><div class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</div><div class="line">                <span class="keyword">return</span> <span class="built_in">NULL</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 新建BpBinder代理</span></div><div class="line">            b = <span class="literal">new</span> BpBinder(<span class="keyword">handle</span>);</div><div class="line">            e-&gt;binder = b;</div><div class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</div><div class="line">            result = b;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="params">...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getStrongProxyForHandle()的目的是返回句柄为handle的IBinder代理，这里是返回Service Manager的IBinder代理，IBinder中存有remoteBinder()和localBinder()</p>
<h4 id="ProcessState-lookupHandleLocked"><a href="#ProcessState-lookupHandleLocked" class="headerlink" title="ProcessState::lookupHandleLocked()"></a><a href="#ProcessState_3A_3AlookupHandleLocked_28_29" title="ProcessState::lookupHandleLocked()"></a>ProcessState::lookupHandleLocked()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ProcessState::handle_entry* ProcessState::lookupHandleLocked(<span class="keyword">int32_t</span> handle)</div><div class="line">&#123;               </div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N=mHandleToObject.size();</div><div class="line">    <span class="keyword">if</span> (N &lt;= (<span class="keyword">size_t</span>)handle) &#123;</div><div class="line">        handle_entry e;</div><div class="line">        e.binder = <span class="literal">NULL</span>;</div><div class="line">        e.refs = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">status_t</span> err = mHandleToObject.insertAt(e, N, handle+<span class="number">1</span>-N);</div><div class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">return</span> &amp;mHandleToObject.editItemAt(handle);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>mHandleToObject是Vector矢量数组，这个方法首先在 mHandleToObject中查找handle的handle_entry，如果存在的话就直接返回，如果不存在，那么就创建一个handle_entry存放在mHandleToObject，这个主要起到一个缓存的作用，不需要每次都去通信。</p>
</li>
<li><p>很显然，此时e!=NULL为true，进入if(e!=NULL)中。而此时e-&gt;binder=NULL，并且handle=0；则调用IPCThreadState::self()-&gt;transact()尝试去和Binder驱动通信(尝试去ping内核中Binder驱动)。由于Binder驱动已启动，ping通信是能够成功的。</p>
</li>
<li><p>接着创建了一个BpBinder对象，并将该对象赋值给了handle_entry的b变量。</p>
</li>
</ol>
<h4 id="BpBinder-BpBinder"><a href="#BpBinder-BpBinder" class="headerlink" title="BpBinder::BpBinder"></a><a href="#BpBinder_3A_3ABpBinder" title="BpBinder::BpBinder"></a>BpBinder::BpBinder</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">BpBinder<span class="type">::BpBinder</span>(int32_t <span class="keyword">handle</span>)</div><div class="line">    : mHandle(<span class="keyword">handle</span>)</div><div class="line">    , mAlive(<span class="number">1</span>)</div><div class="line">    , mObitsSent(<span class="number">0</span>)</div><div class="line">    , mObituaries(<span class="built_in">NULL</span>)</div><div class="line">&#123;</div><div class="line">    ALOGV(<span class="string">"Creating BpBinder %p handle %d\n"</span>, this, mHandle);</div><div class="line"></div><div class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</div><div class="line">    IPCThreadState<span class="type">::self</span>()-&gt;incWeakHandle(<span class="keyword">handle</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建BpBinder对象中会将handle相对应Binder的弱引用增加1.</p>
<h4 id="IPCThreadState-self"><a href="#IPCThreadState-self" class="headerlink" title="IPCThreadState::self()"></a><a href="#IPCThreadState_3A_3Aself_28_29" title="IPCThreadState::self()"></a>IPCThreadState::self()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> gTLSMutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gHaveTLS = <span class="literal">false</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> gTLS = <span class="number">0</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gShutdown = <span class="literal">false</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> gDisableBackgroundScheduling = <span class="literal">false</span>;</div><div class="line"></div><div class="line">IPCThreadState* IPCThreadState::self()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</div><div class="line">restart:</div><div class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</div><div class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</div><div class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (gShutdown) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;gTLSMutex);</div><div class="line">    <span class="keyword">if</span> (!gHaveTLS) &#123;</div><div class="line">        <span class="keyword">if</span> (pthread_key_create(&amp;gTLS, threadDestructor) != <span class="number">0</span>) &#123;</div><div class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        gHaveTLS = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</div><div class="line">    <span class="keyword">goto</span> restart;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>self()的源码比较简单，它的作用是获取IPCThreadState对象。若该对象已经存在，则直接返回；否则，新建IPCThreadState对象</p>
<h4 id="IPCThreadState-IPCThreadState"><a href="#IPCThreadState-IPCThreadState" class="headerlink" title="IPCThreadState::IPCThreadState()"></a><a href="#IPCThreadState_3A_3AIPCThreadState_28_29" title="IPCThreadState::IPCThreadState()"></a>IPCThreadState::IPCThreadState()</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">IPCThreadState</span>::IPCThreadState()</div><div class="line">    : mProcess(<span class="attribute">ProcessState</span>::self()),</div><div class="line">    mMyThreadId(androidGetTid()),</div><div class="line">    mStrictModePolicy(<span class="number">0</span>),</div><div class="line">    mLastTransactionBinderFlags(<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    pthread_setspecific(gTLS, this);</div><div class="line">    <span class="selector-tag">clearCaller</span>();</div><div class="line">    <span class="selector-tag">mIn</span><span class="selector-class">.setDataCapacity</span>(<span class="number">256</span>);</div><div class="line">    <span class="selector-tag">mOut</span><span class="selector-class">.setDataCapacity</span>(<span class="number">256</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>将ProcessState对象赋值给成员变量mProcess</li>
<li>IPCThreadState是与Binder驱动交互的类，那么mIn则表示将要发送给Binder驱动的内容，mOut表示Binder驱动返回的内容</li>
</ol>
<p>到这里ProcessState::getContextObject()就结束了。我们可以简化代码<br>gDefaultServiceManager = interface_cast<iservicemanager>(new BpBinder(0));</iservicemanager></p>
<h3 id="interface-cast"><a href="#interface-cast" class="headerlink" title="interface_cast()"></a><a href="#interface_cast_28_29" title="interface_cast()"></a>interface_cast()</h3><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename <span class="class"><span class="keyword">INTERFACE</span>&gt;</span></div><div class="line"><span class="keyword">inline</span> sp&lt;<span class="class"><span class="keyword">INTERFACE</span>&gt; <span class="title">interface_cast</span>(<span class="title">const</span> <span class="title">sp</span>&lt;<span class="title">IBinder</span>&gt;&amp; <span class="title">obj</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">INTERFACE</span>::<span class="title">asInterface</span>(<span class="title">obj</span>);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的INTERFACE是IServiceManager那么最后返回的是IServiceManager::asInterface(obj)</p>
<h3 id="IServiceManager-asInterface"><a href="#IServiceManager-asInterface" class="headerlink" title="IServiceManager::asInterface()"></a><a href="#IServiceManager_3A_3AasInterface_28_29" title="IServiceManager::asInterface()"></a>IServiceManager::asInterface()</h3><p>对于asInterface()函数，通过搜索代码，你会发现根本找不到这个方法是在哪里定义这个函数的, 其实是通过模板函数来定义的，通过下面两个代码完成的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//位于IServiceManager.h文件</span></div><div class="line"><span class="function"><span class="title">DECLARE_META_INTERFACE</span><span class="params">(ServiceManager)</span></span></div><div class="line"><span class="comment">//位于IServiceManager.cpp文件</span></div><div class="line"><span class="function"><span class="title">IMPLEMENT_META_INTERFACE</span><span class="params">(ServiceManager,<span class="string">"android.os.IServiceManager"</span>)</span></span></div></pre></td></tr></table></figure>
<h4 id="DECLARE-META-INTERFACE"><a href="#DECLARE-META-INTERFACE" class="headerlink" title="DECLARE_META_INTERFACE"></a><a href="#DECLARE_META_INTERFACE" title="DECLARE_META_INTERFACE"></a>DECLARE_META_INTERFACE</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define DECLARE_META_INTERFACE(INTERFACE)                               \</span></div><div class="line">    static const <span class="symbol">android:</span><span class="symbol">:String16</span> descriptor;                          \</div><div class="line">    static <span class="symbol">android:</span><span class="symbol">:sp&lt;I</span><span class="comment">##INTERFACE&gt; asInterface(                       \</span></div><div class="line">            const <span class="symbol">android:</span><span class="symbol">:sp&lt;android</span><span class="symbol">:</span><span class="symbol">:IBinder&gt;&amp;</span> obj);                  \</div><div class="line">    virtual const <span class="symbol">android:</span><span class="symbol">:String16&amp;</span> getInterfaceDescriptor() const;    \</div><div class="line">    I<span class="comment">##INTERFACE();                                                     \</span></div><div class="line">    virtual ~I<span class="comment">##INTERFACE();                                            \</span></div></pre></td></tr></table></figure>
<p>INTERFACE=ServiceManager展开即可得：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;</div><div class="line"></div><div class="line"><span class="keyword">static</span> android::sp&lt; IServiceManager &gt; asInterface(<span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keyword">const</span> android::String16&amp; getInterfaceDescriptor() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">IServiceManager ();</div><div class="line"><span class="keyword">virtual</span> ~IServiceManager();</div></pre></td></tr></table></figure>
<h4 id="IMPLEMENT-META-INTERFACE"><a href="#IMPLEMENT-META-INTERFACE" class="headerlink" title="IMPLEMENT_META_INTERFACE"></a><a href="#IMPLEMENT_META_INTERFACE" title="IMPLEMENT_META_INTERFACE"></a>IMPLEMENT_META_INTERFACE</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</div><div class="line">    const android::String16 I##INTERFACE::descriptor(NAME);             \</div><div class="line">    const android::String16&amp;                                            \</div><div class="line">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</div><div class="line">        return I##INTERFACE::descriptor;                                \</div><div class="line">    &#125;                                                                   \</div><div class="line">    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \</div><div class="line">            const android::sp&lt;android::IBinder&gt;&amp; obj)                   \</div><div class="line">    &#123;                                                                   \</div><div class="line">        android::sp&lt;I##INTERFACE&gt; intr;                                 \</div><div class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</div><div class="line">            intr = static_cast&lt;I##INTERFACE*&gt;(                          \</div><div class="line">                obj-&gt;queryLocalInterface(                               \</div><div class="line">                        I##INTERFACE::descriptor).get());               \</div><div class="line">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</div><div class="line">                intr = new Bp##INTERFACE(obj);                          \</div><div class="line">            &#125;                                                           \</div><div class="line">        &#125;                                                               \</div><div class="line">        return intr;                                                    \</div><div class="line">    &#125;                                                                   \</div><div class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</div><div class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</div></pre></td></tr></table></figure>
<p>INTERFACE=ServiceManager, NAME=”android.os.IServiceManager”展开即可得：<br>const android::String16 IServiceManager::descriptor(“android.os.IServiceManager”);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> android::String16&amp; IServiceManager::getInterfaceDescriptor() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> IServiceManager::descriptor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(<span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)</div><div class="line">&#123;</div><div class="line">    android::sp&lt;IServiceManager&gt; intr;</div><div class="line">        <span class="keyword">if</span>(obj != <span class="literal">NULL</span>) &#123;</div><div class="line">        intr = <span class="keyword">static_cast</span>&lt;IServiceManager *&gt;(</div><div class="line">            obj-&gt;queryLocalInterface(IServiceManager::descriptor).get());</div><div class="line">        <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</div><div class="line">            intr = <span class="keyword">new</span> BpServiceManager(obj);  </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> intr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">IServiceManager::IServiceManager () &#123; &#125;</div><div class="line">IServiceManager::~ IServiceManager() &#123; &#125;</div></pre></td></tr></table></figure>
<p>我们看到了IServiceManager::asInterface方法的实现，new BpServiceManager(obj)</p>
<ol>
<li>obj是传入的BpBinder对象，不为NULL。因此，执行obj-&gt;queryLocalInterface(“android.os.IServiceManager”)来查找名称为”android.os.IServiceManager”的本地接口，queryLocalInterface()的实现在BpBinder的父类IBinder中，具体在文件frameworks/native/libs/binder/Binder.cpp中。很显然，IServiceManager接口还没创建，因此intr=NULL。</li>
<li>新建BpServiceManager(obj)对象，并返回。</li>
</ol>
<p>到目前为止，gDefaultServiceManager的创建流程就分析完了，它实际返回的是一个BpServiceManager对象，该对象包含IBinder的代理BpBinder。以下是转换后的获取gDefaultServiceManager的语句</p>
<p>gDefaultServiceManager = new BpServiceManager(new BpBinder(0));</p>
<h3 id="二-时序图"><a href="#二-时序图" class="headerlink" title="二.时序图"></a><a href="#u4E8C-_u65F6_u5E8F_u56FE" title="二.时序图"></a>二.时序图</h3><p><img src="http://jokero1o.github.io/images/blog_servicemanager_2.png" alt=""></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ServiceManager/">ServiceManager</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android-Binder技术ServiceManager之服务注册请求的发送" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/Android-Binder技术ServiceManager之服务注册请求的发送/" class="article-date">
      <time datetime="2017-04-26T07:26:06.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/Android-Binder技术ServiceManager之服务注册请求的发送/">Android-Binder技术ServiceManager之服务注册请求的发送</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>ServiceManager的启动已经介绍过了,那么ServiceManager的主要功能是注册和获取服务，那么这些功能的前提都是要能够获取ServiceManager，当然这部分我们也上上篇介绍过了，接下来我们就介绍一下具体的一个服务是如果注册的。当然我们选一个Service就可以了。其他的Service都是类似的。那么我们接下来就说说MediaPlayerService是如何注册的。</p>
</blockquote>
<p>MediaPlayerService的入口函数是main_mediaserver.cpp中的main方法。</p>
<h3 id="MediaPlayerService-main"><a href="#MediaPlayerService-main" class="headerlink" title="MediaPlayerService::main()"></a><a href="#MediaPlayerService_3A_3Amain_28_29" title="MediaPlayerService::main()"></a>MediaPlayerService::main()</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">int main(int argc, <span class="built_in">char</span>** argv)</div><div class="line">&#123;</div><div class="line">    signal(SIGPIPE, SIG_IGN);</div><div class="line">    <span class="built_in">char</span> value[PROPERTY_VALUE_MAX];</div><div class="line">    <span class="built_in">bool</span> doLog = (property_get(<span class="string">"ro.test_harness"</span>, value, <span class="string">"0"</span>) &gt; <span class="number">0</span>) &amp;&amp; (atoi(value) == <span class="number">1</span>);</div><div class="line">    pid_t childPid;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</div><div class="line">        ...</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// all other services</span></div><div class="line">        ...</div><div class="line">        sp&lt;ProcessState&gt; <span class="keyword">proc</span>(ProcessState::<span class="keyword">self</span>());</div><div class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">        ...</div><div class="line">        MediaPlayerService::instantiate();</div><div class="line">        ...</div><div class="line">        ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</div><div class="line">        IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>property_get(“ro.test_harness”, value, “0”)是获取”ro.test_harness”属性，为false。</li>
<li>ProcessState:self()是获取ProcessState对象，并赋值给proc,已经介绍过了。</li>
<li>defaultServiceManager()是获取IServiceManager对象，已经介绍过了。</li>
</ol>
<h4 id="MediaPlayerService-instantiate"><a href="#MediaPlayerService-instantiate" class="headerlink" title="MediaPlayerService::instantiate()"></a><a href="#MediaPlayerService_3A_3Ainstantiate_28_29" title="MediaPlayerService::instantiate()"></a>MediaPlayerService::instantiate()</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="literal">void</span> MediaPlayerService::instantiate() &#123;</div><div class="line">    defaultServiceManager<span class="function"><span class="params">()</span>-&gt;</span>addService(</div><div class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>defaultServiceManager() 获取到一个BpServiceManager实例对象，调用addService方法将”media.player”和MediaPlayerService对象。我们客户端可以通过”media.player”来获取该服务。</p>
<h4 id="MediaPlayerService-MediaPlayerService"><a href="#MediaPlayerService-MediaPlayerService" class="headerlink" title="MediaPlayerService::MediaPlayerService()"></a><a href="#MediaPlayerService_3A_3AMediaPlayerService_28_29" title="MediaPlayerService::MediaPlayerService()"></a>MediaPlayerService::MediaPlayerService()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">MediaPlayerService::MediaPlayerService()</div><div class="line">&#123;</div><div class="line">    ALOGV(<span class="string">"MediaPlayerService created"</span>);</div><div class="line">    mNextConnId = <span class="number">1</span>; </div><div class="line"></div><div class="line">    mBatteryAudio.refCount = <span class="number">0</span>; </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_AUDIO_DEVICES; i++) &#123;</div><div class="line">        mBatteryAudio.deviceOn[i] = <span class="number">0</span>; </div><div class="line">        mBatteryAudio.lastTime[i] = <span class="number">0</span>; </div><div class="line">        mBatteryAudio.totalTime[i] = <span class="number">0</span>; </div><div class="line">    &#125;    </div><div class="line">    <span class="comment">// speaker is on by default</span></div><div class="line">    mBatteryAudio.deviceOn[SPEAKER] = <span class="number">1</span>; </div><div class="line">    mOOMKilling = <span class="literal">false</span>;</div><div class="line">    MediaPlayerFactory::registerBuiltinFactories();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单的变量初始化，MediaPlayerService是实现了BBinder的。</p>
<h4 id="BpServiceManager-addService"><a href="#BpServiceManager-addService" class="headerlink" title="BpServiceManager::addService()"></a><a href="#BpServiceManager_3A_3AaddService_28_29" title="BpServiceManager::addService()"></a>BpServiceManager::addService()</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">class</span> <span class="keyword">BpServiceManager </span>: public <span class="keyword">BpInterface&lt;IServiceManager&gt;</span></div><div class="line">&#123;</div><div class="line"><span class="symbol">public</span>:</div><div class="line">    ...</div><div class="line"></div><div class="line">    virtual status_t <span class="keyword">addService(const </span><span class="keyword">String16&amp; </span>name, const <span class="built_in">sp</span>&lt;IBinder&gt;&amp; service,          </div><div class="line">            <span class="keyword">bool </span>allowIsolated)         </div><div class="line">    &#123;     </div><div class="line">        Parcel <span class="meta">data</span>, reply<span class="comment">;             </span></div><div class="line">        <span class="meta">data</span>.writeInterfaceToken(IServiceManager::getInterfaceDescriptor())<span class="comment">;</span></div><div class="line">        <span class="meta">data</span>.writeString16(name)<span class="comment">;       </span></div><div class="line">        <span class="meta">data</span>.writeStrongBinder(service)<span class="comment">;</span></div><div class="line">        <span class="meta">data</span>.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>)<span class="comment">;</span></div><div class="line">        status_t err = remote()-&gt;transact(<span class="keyword">ADD_SERVICE_TRANSACTION, </span><span class="meta">data</span>, &amp;reply)<span class="comment">;          </span></div><div class="line">        return err == NO_ERROR ? reply.readExceptionCode() : err<span class="comment">;</span></div><div class="line">    &#125;     </div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>addService()会现将MediaPlayerService服务的名称(“media.player”)以及它的实例等参数保存到data(Parcel对象)中，然后再调用remote()返回的BpBinder对象的transact()与Binder驱动进行交互。</p>
<h4 id="Parcel-Parcel"><a href="#Parcel-Parcel" class="headerlink" title="Parcel::Parcel()"></a><a href="#Parcel_3A_3AParcel_28_29" title="Parcel::Parcel()"></a>Parcel::Parcel()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Parcel::Parcel()</div><div class="line">&#123;   </div><div class="line">    initState(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Parcel-initState"><a href="#Parcel-initState" class="headerlink" title="Parcel::initState()"></a><a href="#Parcel_3A_3AinitState_28_29" title="Parcel::initState()"></a>Parcel::initState()</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void Parcel::initState()</div><div class="line">&#123;</div><div class="line">    <span class="attr">mError</span> = NO_ERROR;</div><div class="line">    <span class="attr">mData</span> = <span class="number">0</span>;              // 数据的地址指针</div><div class="line">    <span class="attr">mDataSize</span> = <span class="number">0</span>;          // 数据的大小</div><div class="line">    <span class="attr">mDataCapacity</span> = <span class="number">0</span>;      // 数据的容量</div><div class="line">    <span class="attr">mDataPos</span> = <span class="number">0</span>;           // 数据的位置</div><div class="line">    <span class="attr">mObjects</span> = NULL;        // 保存对象的地址指针</div><div class="line">    <span class="attr">mObjectsSize</span> = <span class="number">0</span>;       // 对象的个数</div><div class="line">    <span class="attr">mObjectsCapacity</span> = <span class="number">0</span>;   // 对象的容量</div><div class="line">    <span class="attr">mNextObjectHint</span> = <span class="number">0</span>;</div><div class="line">    <span class="attr">mHasFds</span> = <span class="literal">false</span>;</div><div class="line">    <span class="attr">mFdsKnown</span> = <span class="literal">true</span>;</div><div class="line">    <span class="attr">mAllowFds</span> = <span class="literal">true</span>;</div><div class="line">    <span class="attr">mOwner</span> = NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Parcel将会申请内存地址来保存数据。</p>
<h4 id="BpBinder-transact"><a href="#BpBinder-transact" class="headerlink" title="BpBinder::transact()"></a><a href="#BpBinder_3A_3Atransact_28_29" title="BpBinder::transact()"></a>BpBinder::transact()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> BpBinder::transact(            </div><div class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// mAlive的初始值为1</span></div><div class="line">    <span class="keyword">if</span> (mAlive) &#123;</div><div class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</div><div class="line">            mHandle, code, data, reply, flags);</div><div class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> DEAD_OBJECT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IPCThreadState::self()会获取单例的IPCThreadState对象，并且调用transact方法</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState<span class="type">::transact</span>(int32_t <span class="keyword">handle</span>,</div><div class="line">                                uint32_t code, const Parcel&amp; <span class="built_in">data</span>,</div><div class="line">                                Parcel* reply, uint32_t flags)</div><div class="line">&#123;</div><div class="line">    status_t err = <span class="built_in">data</span>.errorCheck();</div><div class="line"></div><div class="line">    flags |= TF_ACCEPT_FDS;</div><div class="line"></div><div class="line">    <span class="params">...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</div><div class="line">        <span class="params">...</span></div><div class="line">        err = writeTransactionData(BC_TRANSACTION, flags, <span class="keyword">handle</span>, code, <span class="built_in">data</span>, <span class="built_in">NULL</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="params">...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (reply) &#123;</div><div class="line">            err = waitForResponse(reply);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="params">...</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="params">...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>先看看函数的参数。handle是BpBinder中的mHandle对象，BpBinder中的mHandle是ServiceManager的句柄，值为0。code=ADD_SERVICE_TRANSACTION。data就是在addService中设置的Parcel对象。reply是用来接收Binder驱动反馈数据的Parcel对象。flags是默认值0</li>
<li><p>该函数会先通过writeTransactionData()将数据打包</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="title">status_t</span> <span class="type">IPCThreadState</span>::writeTransactionData(int32_t cmd, uint32_t binderFlags,</div><div class="line">    int32_t handle, uint32_t code, const <span class="type">Parcel</span>&amp; <span class="class"><span class="keyword">data</span>, status_t* statusBuffer)</span></div><div class="line">&#123;</div><div class="line">    binder_transaction_data tr;</div><div class="line"></div><div class="line">    tr.target.handle = handle;</div><div class="line">    tr.code = code;</div><div class="line">    tr.flags = binderFlags;</div><div class="line">    tr.cookie = <span class="number">0</span>;</div><div class="line">    tr.sender_pid = <span class="number">0</span>;</div><div class="line">    tr.sender_euid = <span class="number">0</span>;</div><div class="line"></div><div class="line">    const status_t err = <span class="class"><span class="keyword">data</span>.errorCheck();</span></div><div class="line">    <span class="keyword">if</span> (err == <span class="type">NO_ERROR</span>) &#123;</div><div class="line">        tr.data_size = <span class="class"><span class="keyword">data</span>.ipcDataSize();</span></div><div class="line">        tr.<span class="class"><span class="keyword">data</span>.ptr.buffer = <span class="keyword">data</span>.ipcData();</span></div><div class="line">        tr.offsets_size = <span class="class"><span class="keyword">data</span>.ipcObjectsCount()*sizeof(<span class="title">size_t</span>);</span></div><div class="line">        tr.<span class="class"><span class="keyword">data</span>.ptr.offsets = <span class="keyword">data</span>.ipcObjects();</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</div><div class="line">        ..</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&amp;tr, sizeof(tr));</div><div class="line"></div><div class="line">    return <span class="type">NO_ERROR</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数会读取Parcel中的数据，然后将其打包到binder_transaction_data结构体中。binder_transaction_data结构体是Binder驱动能够识别并对之进行解析的数据结构.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="title">tr</span>.target.handle = handle;  // <span class="number">0</span>，即<span class="type">Service</span> <span class="type">Manager</span>的句柄</div><div class="line"><span class="title">tr</span>.code = code;             // <span class="type">ADD_SERVICE_TRANSACTION</span></div><div class="line"><span class="title">tr</span>.flags = binderFlags;     // <span class="type">TF_ACCEPT_FDS</span></div><div class="line"><span class="title">tr</span>.cookie = <span class="number">0</span>;</div><div class="line"><span class="title">tr</span>.sender_pid = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="title">tr</span>.data_size = <span class="class"><span class="keyword">data</span>.ipcDataSize();      // 数据大小(对应<span class="title">mDataSize</span>)</span></div><div class="line"><span class="title">tr</span>.<span class="class"><span class="keyword">data</span>.ptr.buffer = <span class="keyword">data</span>.ipcData();    // 数据的起始地址(对应<span class="title">mData</span>)</span></div><div class="line"><span class="title">tr</span>.offsets_size = <span class="class"><span class="keyword">data</span>.ipcObjectsCount()*sizeof(<span class="title">size_t</span>); // <span class="keyword">data</span>中保存的对象个数(对应<span class="title">mObjectsSize</span>)</span></div><div class="line"><span class="title">tr</span>.<span class="class"><span class="keyword">data</span>.ptr.offsets = <span class="keyword">data</span>.ipcObjects();                 // <span class="keyword">data</span>中保存的对象的偏移地址数组(对应<span class="title">mObjects</span>)</span></div></pre></td></tr></table></figure>
</li>
<li><p>lags的初始化为0，并且reply非空。因此，将数据打包号之后，会调用waitForResponse()将数据发送给Binder驱动，然后等待Binder驱动反馈。</p>
</li>
</ol>
<p>初始化tr之后，将cmd=BC_TRANSACTION和tr重新打包到mOut中。mOut中的数据将来会被以请求的方式发送给Binder驱动</p>
<h4 id="IPCThreadState-waitForResponse"><a href="#IPCThreadState-waitForResponse" class="headerlink" title="IPCThreadState::waitForResponse()"></a><a href="#IPCThreadState_3A_3AwaitForResponse_28_29" title="IPCThreadState::waitForResponse()"></a>IPCThreadState::waitForResponse()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int32_t</span> cmd;</div><div class="line">    <span class="keyword">int32_t</span> err;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 先通过talkWithDriver()和Binder驱动交互</span></div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        ...</div><div class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 然后读取返回结果，再根据结果进行处理</span></div><div class="line">        cmd = mIn.readInt32();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</div><div class="line">            ...</div><div class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</div><div class="line">            ...</div><div class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</div><div class="line">            ...</div><div class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</div><div class="line">            ...</div><div class="line">        <span class="keyword">case</span> BR_REPLY:</div><div class="line">            ...</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = executeCommand(cmd);</div><div class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">finish:</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法会先调用talkWithDriver来发送数据给Binder。然后再等待返回。</p>
<h4 id="IPCThreadState-talkWithDriver"><a href="#IPCThreadState-talkWithDriver" class="headerlink" title="IPCThreadState::talkWithDriver()"></a><a href="#IPCThreadState_3A_3AtalkWithDriver_28_29" title="IPCThreadState::talkWithDriver()"></a>IPCThreadState::talkWithDriver()</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState<span class="type">::talkWithDriver</span>(bool doReceive)</div><div class="line">&#123;</div><div class="line">    <span class="params">...</span></div><div class="line">    binder_write_read bwr;</div><div class="line"></div><div class="line">    <span class="comment">// Is the read buffer empty?</span></div><div class="line">    const bool needRead = <span class="keyword">mIn</span>.dataPosition() &gt;= <span class="keyword">mIn</span>.dataSize();</div><div class="line">    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</div><div class="line"></div><div class="line">    bwr.write_size = outAvail;</div><div class="line">    bwr.write_buffer = (long unsigned int)mOut.<span class="built_in">data</span>();</div><div class="line"></div><div class="line">    <span class="comment">// This is what we'll read.</span></div><div class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</div><div class="line">        bwr.read_size = <span class="keyword">mIn</span>.dataCapacity();</div><div class="line">        bwr.read_buffer = (long unsigned int)<span class="keyword">mIn</span>.<span class="built_in">data</span>();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bwr.read_size = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="params">...</span></div><div class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    status_t err;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="params">...</span></div><div class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</div><div class="line">            err = NO_ERROR;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="params">...</span></div><div class="line">        <span class="params">...</span></div><div class="line">    &#125; <span class="keyword">while</span> (err == <span class="params">-EINTR</span>);</div><div class="line"></div><div class="line">    <span class="params">...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</div><div class="line">        <span class="comment">// 清空已写的数据</span></div><div class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())</div><div class="line">                mOut.remove(<span class="number">0</span>, bwr.write_consumed);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                mOut.setDataSize(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置已读数据</span></div><div class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">mIn</span>.setDataSize(bwr.read_consumed);</div><div class="line">            <span class="keyword">mIn</span>.setDataPosition(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="params">...</span></div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互</p>
<h4 id="binder-ioctl-BINDER-WRITE-READ"><a href="#binder-ioctl-BINDER-WRITE-READ" class="headerlink" title="binder_ioctl(BINDER_WRITE_READ)"></a><a href="#binder_ioctl_28BINDER_WRITE_READ_29" title="binder_ioctl(BINDER_WRITE_READ)"></a>binder_ioctl(BINDER_WRITE_READ)</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">static</span> long <span class="keyword">binder_ioctl(struct </span>file *filp, unsigned int cmd, unsigned long arg)</div><div class="line">&#123;</div><div class="line"><span class="symbol">int</span> ret<span class="comment">;</span></div><div class="line"><span class="keyword">struct </span><span class="keyword">binder_proc </span>*<span class="meta">proc</span> = filp-&gt;private_data<span class="comment">;</span></div><div class="line"><span class="keyword">struct </span><span class="keyword">binder_thread </span>*thread<span class="comment">;</span></div><div class="line"><span class="symbol">unsigned</span> int size = _IOC_SIZE(cmd)<span class="comment">;</span></div><div class="line"><span class="symbol">void</span> __user *ubuf = (void __user *)arg<span class="comment">;</span></div><div class="line"></div><div class="line">// 中断等待函数。</div><div class="line">// <span class="number">1</span>\. 当<span class="keyword">binder_stop_on_user_error </span>&lt; <span class="number">2</span>为true时；不会进入等待状态；直接跳过。</div><div class="line">// <span class="number">2</span>\. 当<span class="keyword">binder_stop_on_user_error </span>&lt; <span class="number">2</span>为false时，进入等待状态。</div><div class="line">//    当有其他进程通过wake_up_interruptible来唤醒<span class="keyword">binder_user_error_wait队列，并且binder_stop_on_user_error </span>&lt; <span class="number">2</span>为true时；</div><div class="line">//    则继续执行；否则，再进入等待状态。</div><div class="line"><span class="symbol">ret</span> = wait_event_interruptible(<span class="keyword">binder_user_error_wait, </span><span class="keyword">binder_stop_on_user_error </span>&lt; <span class="number">2</span>)<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="keyword">binder_lock(__func__);</span></div><div class="line">// 在<span class="meta">proc</span>进程中查找该线程对应的<span class="keyword">binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></div><div class="line"><span class="symbol">thread</span> = <span class="keyword">binder_get_thread(proc);</span></div><div class="line"><span class="symbol">...</span></div><div class="line"></div><div class="line"><span class="keyword">switch </span>(cmd) &#123;</div><div class="line"><span class="symbol">case</span> <span class="keyword">BINDER_WRITE_READ: </span>&#123;</div><div class="line">    <span class="keyword">struct </span><span class="keyword">binder_write_read </span><span class="keyword">bwr;</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    // 将<span class="keyword">binder_write_read从"用户空间" </span>拷贝到 <span class="string">"内核空间"</span></div><div class="line">    <span class="meta">if</span> (copy_from_user(&amp;<span class="keyword">bwr, </span>ubuf, sizeof(<span class="keyword">bwr))) </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果write_size&gt;<span class="number">0</span>，则进行写操作</div><div class="line">    <span class="meta">if</span> (<span class="keyword">bwr.write_size </span>&gt; <span class="number">0</span>) &#123;</div><div class="line">        ret = <span class="keyword">binder_thread_write(proc, </span>thread, (void __user *)<span class="keyword">bwr.write_buffer, </span><span class="keyword">bwr.write_size, </span>&amp;<span class="keyword">bwr.write_consumed);</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果read_size&gt;<span class="number">0</span>，则进行读操作</div><div class="line">    <span class="meta">if</span> (<span class="keyword">bwr.read_size </span>&gt; <span class="number">0</span>) &#123;</div><div class="line">        ret = <span class="keyword">binder_thread_read(proc, </span>thread, (void __user *)<span class="keyword">bwr.read_buffer, </span><span class="keyword">bwr.read_size, </span>&amp;<span class="keyword">bwr.read_consumed, </span>filp-&gt;f_flags   &amp; O_NONBLOCK)<span class="comment">;</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">if</span> (copy_to_user(ubuf, &amp;<span class="keyword">bwr, </span>sizeof(<span class="keyword">bwr))) </span>&#123;</div><div class="line">        ret = -EFAULT<span class="comment">;</span></div><div class="line">        goto err<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break;</span></div><div class="line">&#125;</div><div class="line"><span class="symbol">...</span></div><div class="line">&#125;</div><div class="line"><span class="symbol">ret</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line"></div><div class="line"><span class="symbol">...</span></div><div class="line"><span class="symbol">return</span> ret<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时的write_size&gt;0那么就会调用binder_thread_write方法</p>
<p>这个函数上篇已经介绍过了。这里将binder_write_read从用户空间拷贝到内核空间之后，读取bwr.write_size和bwr.read_size都&gt;0，因此先写后读。<br>这个方法在后会调用binder_transaction函数</p>
<h4 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction()"></a><a href="#binder_transaction_28_29" title="binder_transaction()"></a>binder_transaction()</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line">static void binder_transaction(struct binder_proc *proc,</div><div class="line">            struct binder_thread *thread,</div><div class="line">            struct binder_transaction_data *tr, int reply)&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reply) &#123;</div><div class="line">        ...</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="function"><span class="title">if</span> (tr-&gt;</span>target.handle) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// handle=0则找到servicemanager实体</span></div><div class="line">            target_node = binder_context_mgr_node;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//target_proc为servicemanager进程</span></div><div class="line">        <span class="function"><span class="title">target_proc</span> = target_node-&gt;</span>proc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (target_thread) &#123;</div><div class="line">        ...</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//找到servicemanager进程的todo队列</span></div><div class="line">        <span class="function"><span class="title">target_list</span> = &amp;target_proc-&gt;</span>todo;</div><div class="line">        <span class="function"><span class="title">target_wait</span> = &amp;target_proc-&gt;</span>wait;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t = kzalloc(sizeof(*t), GFP_KERNEL);</div><div class="line">    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);</div><div class="line"></div><div class="line">    <span class="comment">//非oneway的通信方式，把当前thread保存到transaction的from字段</span></div><div class="line">    <span class="function"><span class="title">if</span> (!reply &amp;&amp; !(tr-&gt;</span>flags &amp; TF_ONE_WAY))</div><div class="line">        <span class="function"><span class="title">t</span>-&gt;</span>from = thread;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="function"><span class="title">t</span>-&gt;</span>from = NULL;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">sender_euid</span> = task_euid(proc-&gt;</span>tsk);</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>to_proc = target_proc; <span class="comment">//此次通信目标进程为servicemanager进程</span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>to_thread = target_thread;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">code</span> = tr-&gt;</span>code;  <span class="comment">//此次通信code = ADD_SERVICE_TRANSACTION</span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">flags</span> = tr-&gt;</span>flags;  <span class="comment">// 此次通信flags = 0</span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>priority = task_nice(current);</div><div class="line"></div><div class="line">    <span class="comment">//从servicemanager进程中分配buffer</span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">buffer</span> = binder_alloc_buf(target_proc, tr-&gt;</span>data_size,</div><div class="line">        <span class="function"><span class="title">tr</span>-&gt;</span><span class="function"><span class="title">offsets_size</span>, !reply &amp;&amp; (t-&gt;</span>flags &amp; TF_ONE_WAY));</div><div class="line"></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">buffer</span>-&gt;</span>allow_user_free = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">buffer</span>-&gt;</span>transaction = t;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">buffer</span>-&gt;</span>target_node = target_node;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (target_node)</div><div class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, NULL); <span class="comment">//引用计数加1</span></div><div class="line">    <span class="function"><span class="title">offp</span> = (binder_size_t *)(t-&gt;</span><span class="function"><span class="title">buffer</span>-&gt;</span><span class="function"><span class="title">data</span> + ALIGN(tr-&gt;</span>data_size, sizeof(void *)));</div><div class="line"></div><div class="line">    <span class="comment">//分别拷贝用户空间的binder_transaction_data中ptr.buffer和ptr.offsets到内核</span></div><div class="line">    <span class="function"><span class="title">copy_from_user</span>(t-&gt;</span><span class="function"><span class="title">buffer</span>-&gt;</span><span class="keyword">data</span>,</div><div class="line">        (<span class="function"><span class="title">const</span> void __user *)(uintptr_t)tr-&gt;</span><span class="function"><span class="title">data</span>.ptr.buffer, tr-&gt;</span>data_size);</div><div class="line">    copy_from_user(offp,</div><div class="line">        (<span class="function"><span class="title">const</span> void __user *)(uintptr_t)tr-&gt;</span><span class="function"><span class="title">data</span>.ptr.offsets, tr-&gt;</span>offsets_size);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">off_end</span> = (void *)offp + tr-&gt;</span>offsets_size;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</div><div class="line">        struct flat_binder_object *fp;</div><div class="line">        <span class="function"><span class="title">fp</span> = (struct flat_binder_object *)(t-&gt;</span><span class="function"><span class="title">buffer</span>-&gt;</span><span class="keyword">data</span> + *offp);</div><div class="line">        off_min = *offp + sizeof(struct flat_binder_object);</div><div class="line">        <span class="function"><span class="title">switch</span> (fp-&gt;</span>type) &#123;</div><div class="line">            case BINDER_TYPE_BINDER:</div><div class="line">            case BINDER_TYPE_WEAK_BINDER: &#123;</div><div class="line">            struct binder_ref *ref;</div><div class="line">            <span class="comment">//【见4.3.1】</span></div><div class="line">            <span class="function"><span class="title">struct</span> binder_node *node = binder_get_node(proc, fp-&gt;</span>binder);</div><div class="line">            <span class="keyword">if</span> (node == NULL) &#123; </div><div class="line">                <span class="comment">//服务所在进程 创建binder_node实体【见4.3.2】</span></div><div class="line">                <span class="function"><span class="title">node</span> = binder_new_node(proc, fp-&gt;</span><span class="function"><span class="title">binder</span>, fp-&gt;</span>cookie);</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//servicemanager进程binder_ref【见4.3.3】</span></div><div class="line">            ref = binder_get_ref_for_node(target_proc, node);</div><div class="line">            ...</div><div class="line">            <span class="comment">//调整type为HANDLE类型</span></div><div class="line">            <span class="function"><span class="title">if</span> (fp-&gt;</span>type == BINDER_TYPE_BINDER)</div><div class="line">                <span class="function"><span class="title">fp</span>-&gt;</span>type = BINDER_TYPE_HANDLE;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="function"><span class="title">fp</span>-&gt;</span>type = BINDER_TYPE_WEAK_HANDLE;</div><div class="line">            <span class="function"><span class="title">fp</span>-&gt;</span>binder = <span class="number">0</span>;</div><div class="line">            <span class="function"><span class="title">fp</span>-&gt;</span><span class="function"><span class="title">handle</span> = ref-&gt;</span>desc; <span class="comment">//设置handle值</span></div><div class="line">            <span class="function"><span class="title">fp</span>-&gt;</span>cookie = <span class="number">0</span>;</div><div class="line">            <span class="function"><span class="title">binder_inc_ref</span>(ref, fp-&gt;</span>type == BINDER_TYPE_HANDLE,</div><div class="line">                    &amp;<span class="function"><span class="title">thread</span>-&gt;</span>todo);</div><div class="line">            &#125; break;</div><div class="line">            case :...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reply) &#123;</div><div class="line">        ..</div><div class="line">    &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (!(t-&gt;</span>flags &amp; TF_ONE_WAY)) &#123;</div><div class="line">        <span class="comment">//BC_TRANSACTION 且 非oneway,则设置事务栈信息</span></div><div class="line">        <span class="function"><span class="title">t</span>-&gt;</span>need_reply = <span class="number">1</span>;</div><div class="line">        <span class="function"><span class="title">t</span>-&gt;</span><span class="function"><span class="title">from_parent</span> = thread-&gt;</span>transaction_stack;</div><div class="line">        <span class="function"><span class="title">thread</span>-&gt;</span>transaction_stack = t;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//将BINDER_WORK_TRANSACTION添加到目标队列，本次通信的目标队列为target_proc-&gt;todo</span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>work.type = BINDER_WORK_TRANSACTION;</div><div class="line">    <span class="function"><span class="title">list_add_tail</span>(&amp;t-&gt;</span>work.entry, target_list);</div><div class="line"></div><div class="line">    <span class="comment">//将BINDER_WORK_TRANSACTION_COMPLETE添加到当前线程的todo队列</span></div><div class="line">    <span class="function"><span class="title">tcomplete</span>-&gt;</span>type = BINDER_WORK_TRANSACTION_COMPLETE;</div><div class="line">    <span class="function"><span class="title">list_add_tail</span>(&amp;tcomplete-&gt;</span><span class="function"><span class="title">entry</span>, &amp;thread-&gt;</span>todo);</div><div class="line"></div><div class="line">    <span class="comment">//唤醒等待队列，本次通信的目标队列为target_proc-&gt;wait</span></div><div class="line">    <span class="keyword">if</span> (target_wait)</div><div class="line">        wake_up_interruptible(target_wait);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的目标节点是ServiceManager的Binder实体。这个的addService指令最后是交给ServiceManager来处理的。这个时候会创建1个待处理事务t和一个带完成事务tcomplete，并进行初始化，事务t是交给ServiceManager也就是目标进程来处理，tcomplete事务是返回给MediaPlayerService服务的，用来说明Binder请求已经收到。<br>在初始化完待完成任务t之后，接着讲用户空间的数据拷贝到内核空间，从内存数据中解析MediaPlayerService请求的数据中的flat_binder_object对象。改对象的类型是BINDER_TYPE_BINDER，然后调用binder_get_node来寻找当前进程的上下文环境proc中查找fp-&gt;binder对象的Binder实体。fp-&gt;binder是MediaPlayerService在本地引用的描述。即ServiceManager的BBinder的实例引用的描述。在此时是初次交互，proc中并没有本地BBinder对象描述所对应的Binder实体（MediaPlayerService的BpBinder对应的实体）。接下来调用binder_new_node来创建一个对应的Binder实体。也就是BpBinder对象是实体。然后调用binder_get_ref_for_node来chaz目标上下问proc的Binder实体用，这个对象是刚刚创建出来的，所以在ServiceManager的proc中是找不到的。那么就创建该Binder实体的引用并且添加到refs_by_node的红黑树和refs_by_desc红黑树中。这样，ServiceManager就可以通过这个引用来管理这个Service</p>
<p>那么此时的MediaPlayerService上下文中的proc保存了BpBinder，同是也持有了fp-&gt;binder本地BBinder的引用，同是ServiceManager的proc中也保存了BpBinder的引用，可与对MediaPlayerService服务进行管理。</p>
<p>然后，设置待处理事务的类型为BINDER_WORK_TRANSACTION,并将其加入到target_list队列中，此时的目标是ServiceManager，那么就会唤醒ServiceManager对象的事务处理队列。<br>设置待完成工作类型为BINDER_WORK_TRANSACTION_COMPLETE,并将其加入到当前线程的待完成队列中，主要是用来告知MediaPlayerService发送给Binder驱动的请求已被处理了。</p>
<p>此时的MediaPlayerService进程继续运行，并且调用wake_up_interruptible唤醒了ServiceManager进程。被唤醒的ServiceManager将会去处理MediaPlayerService加入到该进程待完成任务队列的任务。所做的工作就是将这个服务注册到服务队列中进行管理。</p>
<p>binder_transaction方法主要的工作是</p>
<ol>
<li>解析MediaPlayerService发送过来的数据。</li>
<li>新建MediaPlayerService对象的BpBinder的Binder实体和引用，并将该引用加入到ServiceManager的proc中，用于以后的管理。</li>
<li>创建待处理事务，并将该事务加入到ServiceManager的待处理事务队列中，接着唤醒ServiceManager进程处理这个事务。</li>
<li>创建待完成事务，并将该事务加入到当前进程的待完成事务队列，也就是MediaPlayerService所在进程，</li>
</ol>
<h4 id="binder-thread-read"><a href="#binder-thread-read" class="headerlink" title="binder_thread_read()"></a><a href="#binder_thread_read_28_29" title="binder_thread_read()"></a>binder_thread_read()</h4><p>接下来ioctl将会把处理后的数据返回给当前进程里来。<br>static int binder_thread_read(struct binder_proc _proc,<br>struct binder<em>thread</em> thread,<br>void <strong>user <em>buffer, int size,<br>signed long</em> consumed, int non_block)<br>{<br>void</strong> user <em>ptr = buffer +</em> consumed;<br>void __user *end = buffer + size;</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">    int ret = <span class="number">0</span>;</div><div class="line">    int wait_for_proc_work;</div><div class="line"></div><div class="line">    <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></div><div class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (uint32_t __user *)ptr))</div><div class="line">            <span class="keyword">return</span> <span class="params">-EFAULT</span>;</div><div class="line">        ptr += sizeof(uint32_t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">retry:</div><div class="line">    <span class="comment">// 等待proc进程的事务标记。</span></div><div class="line">    <span class="comment">// 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。</span></div><div class="line">    wait_for_proc_work = <span class="keyword">thread</span>-&gt;transaction_stack == <span class="built_in">NULL</span> &amp;&amp;</div><div class="line">                list_empty(&amp;<span class="keyword">thread</span>-&gt;todo);</div><div class="line"></div><div class="line">    <span class="params">...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</div><div class="line">        <span class="params">...</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (non_block) &#123;</div><div class="line">            <span class="params">...</span></div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible(<span class="keyword">thread</span>-&gt;wait, binder_has_thread_work(<span class="keyword">thread</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="params">...</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        uint32_t cmd;</div><div class="line">        struct binder_transaction_data tr;</div><div class="line">        struct binder_work *w;</div><div class="line">        struct binder_transaction *t = <span class="built_in">NULL</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></div><div class="line">        <span class="keyword">if</span> (!list_empty(&amp;<span class="keyword">thread</span>-&gt;todo))</div><div class="line">            w = list_first_entry(&amp;<span class="keyword">thread</span>-&gt;todo, struct binder_work, entry);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</div><div class="line">            <span class="params">...</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(<span class="keyword">thread</span>-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></div><div class="line">                goto retry;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="params">...</span></div><div class="line"></div><div class="line">        switch (w-&gt;<span class="keyword">type</span>) &#123;</div><div class="line">        <span class="params">...</span></div><div class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</div><div class="line">            cmd = BR_TRANSACTION_COMPLETE;</div><div class="line">            <span class="comment">// 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中</span></div><div class="line">            <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> <span class="params">-EFAULT</span>;</div><div class="line">            ptr += sizeof(uint32_t);</div><div class="line"></div><div class="line">            binder_stat_br(proc, <span class="keyword">thread</span>, cmd);</div><div class="line">            <span class="params">...</span></div><div class="line"></div><div class="line">            <span class="comment">// 待完成事务已经处理完毕，将其从待完成事务队列中删除。</span></div><div class="line">            list_del(&amp;w-&gt;entry);</div><div class="line">            kfree(w);</div><div class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</div><div class="line">        &#125; break;</div><div class="line">        <span class="params">...</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!t)</div><div class="line">            continue;</div><div class="line"></div><div class="line">        <span class="params">...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="params">...</span></div><div class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></div><div class="line">    *consumed = ptr - buffer;</div><div class="line"></div><div class="line">    <span class="params">...</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>当前的consumed=0表示反馈的数据还没有被读取。那么就拷贝BR_NOOP到用户空间。</li>
<li>binder_has_thread_work(thread)为true，不会进入中断函数，继续往下执行</li>
<li>接着进入循环从带完成队列中取出任务t,待完成的事务处理完毕就会去释放内存删除工作</li>
<li>跳出循环更新consumed值 == 8</li>
</ol>
<p>接着看经过读写之后的talkWithDriver方法调用waitForResponse</p>
<h4 id="IPCThreadState-waitForResponse-1"><a href="#IPCThreadState-waitForResponse-1" class="headerlink" title="IPCThreadState::waitForResponse()"></a><a href="#IPCThreadState_3A_3AwaitForResponse_28_29-1" title="IPCThreadState::waitForResponse()"></a>IPCThreadState::waitForResponse()</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</div><div class="line">&#123;       </div><div class="line">    int32_t cmd<span class="comment">;</span></div><div class="line">    int32_t <span class="keyword">err</span><span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 先通过talkWithDriver()和Binder驱动交互</span></div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">err</span>=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span><span class="comment">;</span></div><div class="line">        <span class="keyword">err</span> = mIn.errorCheck()<span class="comment">;</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">err</span> &lt; NO_ERROR) <span class="keyword">break</span><span class="comment">;</span></div><div class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span><span class="comment">;</span></div><div class="line"></div><div class="line">        <span class="comment">// 然后读取返回结果，再根据结果进行处理</span></div><div class="line">        cmd = mIn.readInt32()<span class="comment">;</span></div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</div><div class="line">            ...</div><div class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</div><div class="line">            ...</div><div class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</div><div class="line">            ...</div><div class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</div><div class="line">            ...</div><div class="line">        <span class="keyword">case</span> BR_REPLY:</div><div class="line">            ...</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">err</span> = executeCommand(cmd)<span class="comment">;</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">err</span> != NO_ERROR) <span class="keyword">goto</span> finish<span class="comment">;</span></div><div class="line">            <span class="keyword">break</span><span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">finish:</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">err</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>talkWithDrive方法之后就会去解析返回过来保存在mIn中的数据，而mIn中的数据是Binder驱动回的”BR_NOOP”和“BR_TRANSACTION_COMPLETE”两个命令。先读取的是BR_NOOP命令，因此执行executeCommand(cmd)</p>
<h4 id="IPCThreadState-executeCommand"><a href="#IPCThreadState-executeCommand" class="headerlink" title="IPCThreadState::executeCommand()"></a><a href="#IPCThreadState_3A_3AexecuteCommand_28_29" title="IPCThreadState::executeCommand()"></a>IPCThreadState::executeCommand()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</div><div class="line">&#123;</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">    <span class="keyword">case</span> BR_ERROR:</div><div class="line">        ...</div><div class="line">    <span class="keyword">case</span> BR_OK:</div><div class="line">        ...</div><div class="line">    <span class="keyword">case</span> BR_NOOP:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</div><div class="line">        mLastError = result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BR_NOOP指令没有进行任何操作直接break<br>从新开始While循环 执行talkWithDriver()</p>
<ol>
<li>此时在上次的读取中已经读取过一次BR_NOOP所以mIn.dataPosition=4,而mIn的dataSize=8；所以needRead = false.</li>
<li>needRead=false，doReceive = true。bwr.read_size = 0;bwr.read_buffer = 0;直接return NO_ERROR<br>直接调用waitForResponse，此时的cmd为BR_TRANSACTION_COMPLETE。此时的reply不为空，因此再次执行while循环调用talkWithDriver<br>此时已经取得玩mIn中的数据</li>
</ol>
<p>MediaPlayerService已经处理完addService这个请求，包括处理完了请求的反馈。对于MediaPlayerService而已已经完成了注册，可以等待Client端来请求。MediaPlayerService通过读取待处理事务队列中的任务，如果有就执行Client的请求，没有就进入中断。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ServiceManager/">ServiceManager</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Fragment弃坑之旅" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/Fragment弃坑之旅/" class="article-date">
      <time datetime="2017-04-26T07:24:30.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/Fragment弃坑之旅/">Fragment弃坑之旅</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>Fragment至诞生之日起，就开始饱受争议，很多人都认为Fragment的设计不合理，并提倡放弃Fragment，这种现象产生的原因我觉得大概就是使用了Fragment之后出现了很多Crash，而且这个Bug都似乎不是太能理解，导致不能很好的去解决。当然任何事物都是有两面性，存在即合理，Fragment肯定也是有其使用价值的。</p>
</blockquote>
<p><img src="http://jokero1o.github.io/images/blog_fragment.jpg" alt=""></p>
<p>由于在使用Fragment的过程中会产生莫名其妙的Crash，这类Crash很隐蔽，一不小心就会出现等特点。我们来总结下具体的Crash来在开发中保证Fragment开发的稳定性，减少Crash的发生率。</p>
<h2 id="getActivity-方法报NPE"><a href="#getActivity-方法报NPE" class="headerlink" title="getActivity()方法报NPE"></a><a href="#getActivity_28_29_u65B9_u6CD5_u62A5NPE" title="getActivity()方法报NPE"></a>getActivity()方法报NPE</h2><p>一般在应用正常使用这个API时是没有任何问题的,而且在测试的过程中也很难出现，但是在App上线后时不时的就会有这样的Crash产生，那就很奇怪了，也是个头疼的问题，而且这类错误不容易复现，那么这势必会让程序员给Fragment减分。那么我们来看下这个API是怎么调用的。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="function">FragmentActivity <span class="title">getActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mHost == <span class="keyword">null</span> ? <span class="keyword">null</span> : (FragmentActivity) mHost.getActivity();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mHost是Fragment绑定的宿主Activity，那么当这个方法返回为Null,可以看到其实是这个变量mHost为Null。<br>我们来看下这个值是从何而来的，那么又在什么时候失去的。我们将查看源码来解决这个问题。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">xxxFragment = XXXFragment.<span class="keyword">new</span><span class="type">Instance</span>(<span class="literal">null</span>);</div><div class="line">getFragmentManager()</div><div class="line">    .beginTransaction()</div><div class="line">    .replace(R.id.container,xxxFragment)</div><div class="line">    .commit();</div></pre></td></tr></table></figure>
<p>上面的代码是我们将一个Fragment加入到Activity的常用手段。那么Fragment的神奇的生命之旅也开始了。我们主要是找到mHost这个变量是如果产生和消失的，并不打算详细的介绍Fragment的每个生命周期的动作。我们在Fragment源码中并没有找到mHost的赋值过程，那么mHost的赋值肯定是从下面的一段代码开始的了。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function">FragmentManager <span class="title">getFragmentManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> mFragments.<span class="title">getFragmentManager</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在Activity中找到如上代码，那么mFragments又是什么，在哪里实例化的呢。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="keyword">new</span> HostCallbacks());</div></pre></td></tr></table></figure>
<p>原来mFragments是FragmentController实例变量，在Activity初始化的时候就开始实例化的了。好的，我们来看下这段代码。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//隐藏了构造函数</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function">FragmentController <span class="title">createController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FragmentController(callbacks);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">FragmentController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;</div><div class="line">    mHost = callbacks;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用父类的构造</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HostCallbacks</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(Activity.<span class="keyword">this</span> <span class="comment">/*activity*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//父类构造</span></div><div class="line">FragmentHostCallback(Activity activity, Context context, Handler <span class="keyword">handler</span>,</div><div class="line">    <span class="keyword">int</span> windowAnimations) &#123;</div><div class="line">    mActivity = activity;</div><div class="line">    mContext = context;</div><div class="line">    mHandler = <span class="keyword">handler</span>;</div><div class="line">    mWindowAnimations = windowAnimations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到HostCallbacks包含了Activity的引用,并且传给了FragmentHostCallback,FragmentController在构造函数里持有了FragmentHostCallback对象。这样的话FragmentController就可以操作mHost来操作FragmentHostCallback中的FragmentManagerImpl对象了。getFragmentManager()也就拿到了FragmentManagerImpl对象的引用。我们再来看下beginTransaction()方法。<br>//FragmentManagerImpl.java<br>//返回了一个BackStackRecord,同是有把自己作为参数传了过去<br>//BackStackRecord的mManager持有了FragmentManagerImpl的引用<br>public FragmentTransaction beginTransaction() {<br>return new BackStackRecord(this);<br>}</p>
<p>接下来我们来看下BackStackRecord的replace方法:</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function">FragmentTransaction <span class="title">replace</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment)</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">return</span> <span class="title">replace</span><span class="params">(containerViewId, fragment, <span class="keyword">null</span>)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function">FragmentTransaction <span class="title">replace</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (containerViewId == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must use non-zero containerViewId"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        doAddOp(containerViewId, fragment, tag, OP_REPLACE);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">将FragmentManagerImpl的引用传给xxxFragment</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doAddOp</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag, <span class="keyword">int</span> opcmd)</span> </span>&#123;</div><div class="line">    fragment.mFragmentManager = mManager;</div><div class="line">    ...</div><div class="line">    Op op = <span class="keyword">new</span> Op();</div><div class="line">    op.cmd = opcmd; <span class="comment">//这里的opcmd为OP_REPLACE</span></div><div class="line">    op.fragment = fragment;</div><div class="line">    addOp(op);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Op为一个链表结构，主要用来记录Fragment的使用链</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</div><div class="line">        mHead = mTail = op;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        op.prev = mTail;</div><div class="line">        mTail.next = op;</div><div class="line">        mTail = op;</div><div class="line">    &#125;</div><div class="line">    op.enterAnim = mEnterAnim;</div><div class="line">    op.exitAnim = mExitAnim;</div><div class="line">    op.popEnterAnim = mPopEnterAnim;</div><div class="line">    op.popExitAnim = mPopExitAnim;</div><div class="line">    mNumOp++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么到现在为止，好像并没有什么实质的变化，Activity依然是个空的Activity，Fragment依然是个没有展示的Fragment。那么重量级的方法来了commit()方法。这个方法对有些刚刚使用Fragment的开发者来说容易忘记的方法。常常写完发现并没有什么XX用。我看看到commit()依然是BackStackRecord的方法.</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//allowStateLoss=false</span></div><div class="line"><span class="comment">//mAddToBackStack默认为false</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mCommitted) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"commit already called"</span>);</div><div class="line">    <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) &#123;</div><div class="line">        Log.v(TAG, <span class="string">"Commit: "</span> + <span class="keyword">this</span>);</div><div class="line">        LogWriter logw = <span class="keyword">new</span> LogWriter(TAG);</div><div class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(logw);</div><div class="line">        dump(<span class="string">"  "</span>, <span class="keyword">null</span>, pw, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    mCommitted = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</div><div class="line">        mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mIndex = <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss);<span class="comment">//mManager为FragmentManagerImpl</span></div><div class="line">    <span class="keyword">return</span> mIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看FragmentManagerImpl的enqueueAction方法:<br>//action 为BackStackRecord对象<br>public void enqueueAction(Runnable action, boolean allowStateLoss) {<br>if (!allowStateLoss) {<br>checkStateLoss();<br>}<br>synchronized (this) {<br>if (mDestroyed || mHost == null) {<br>throw new IllegalStateException(“Activity has been destroyed”);<br>}<br>if (mPendingActions == null) {<br>mPendingActions = new ArrayList<runnable>();<br>}<br>mPendingActions.add(action);<br>if (mPendingActions.size() == 1) {<br>mHost.getHandler().removeCallbacks(mExecCommit);<br>mHost.getHandler().post(mExecCommit);<br>}<br>}<br>}<br>这段代码主要是去执行传进来的Runable的run方法。</runnable></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">   ...</div><div class="line">    Op <span class="attr">op</span> = mHead;</div><div class="line">    while (op != <span class="literal">null</span>) &#123;</div><div class="line">        ...</div><div class="line">            case OP_REPLACE: &#123;</div><div class="line">                Fragment <span class="attr">f</span> = op.fragment;</div><div class="line">                int <span class="attr">containerId</span> = f.mContainerId;</div><div class="line">                <span class="keyword">if</span> (mManager.mAdded != <span class="literal">null</span>) &#123;</div><div class="line">                    for (int <span class="attr">i</span> = mManager.mAdded.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                        Fragment <span class="attr">old</span> = mManager.mAdded.get(i);</div><div class="line">                        <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) Log.v(TAG,</div><div class="line">                                <span class="string">"OP_REPLACE: adding="</span> + f + <span class="string">" old="</span> + old);</div><div class="line">                        <span class="keyword">if</span> (old.<span class="attr">mContainerId</span> == containerId) &#123;</div><div class="line">                            <span class="keyword">if</span> (<span class="attr">old</span> == f) &#123;</div><div class="line">                                op.<span class="attr">fragment</span> = <span class="attr">f</span> = <span class="literal">null</span>;</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="keyword">if</span> (op.<span class="attr">removed</span> == <span class="literal">null</span>) &#123;</div><div class="line">                                    op.<span class="attr">removed</span> = new ArrayList&lt;Fragment&gt;();</div><div class="line">                                &#125;</div><div class="line">                                op.removed.add(old);</div><div class="line">                                old.<span class="attr">mNextAnim</span> = exitAnim;</div><div class="line">                                <span class="keyword">if</span> (mAddToBackStack) &#123;</div><div class="line">                                    old.mBackStackNesting += <span class="number">1</span>;</div><div class="line">                                    <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) Log.v(TAG, <span class="string">"Bump nesting of "</span></div><div class="line">                                            + old + <span class="string">" to "</span> + old.mBackStackNesting);</div><div class="line">                                &#125;</div><div class="line">                                mManager.removeFragment(old, transition, transitionStyle);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</div><div class="line">                    f.<span class="attr">mNextAnim</span> = enterAnim;</div><div class="line">                    mManager.addFragment(f, <span class="literal">false</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; break;</div><div class="line">            ...</div><div class="line">            mManager.moveToState(mManager.mCurState, transition, transitionStyle, <span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码很长，但是我们只关心OP_REPLACE的操作符。我们看到上面的代码主要是通过操作FragmentManagerImpl来remove老的Fragment，add新的Fragment。好的，我们把重点给到addFragment这个方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> void addFragment(Fragment fragment, boolean moveToStateNow) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.mAdded == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.mAdded = new ArrayList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(DEBUG) &#123;</div><div class="line">        Log.v(<span class="string">"FragmentManager"</span>, <span class="string">"add: "</span> + fragment);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.makeActive(fragment); <span class="comment">// 将Fragment放入mActive集合中待显示</span></div><div class="line">    <span class="keyword">if</span>(!fragment.mDetached) &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.mAdded.contains(fragment)) &#123;</div><div class="line">            <span class="keyword">throw</span> new IllegalStateException(<span class="string">"Fragment already added: "</span> + fragment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.mAdded.add(fragment);</div><div class="line">        fragment.mAdded = <span class="literal">true</span>;</div><div class="line">        fragment.mRemoving = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</div><div class="line">            <span class="keyword">this</span>.mNeedMenuInvalidate = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        moveToStateNow == <span class="literal">false</span></div><div class="line">        <span class="keyword">if</span>(moveToStateNow) &#123;</div><div class="line">            <span class="keyword">this</span>.moveToState(fragment);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里最关键的代码是makeActive(fragment)。我们在回到BackStackRecord的run方法中，走过一系列的case后走到最后的方法moveToState。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void moveToState(int <span class="keyword">new</span><span class="type">State</span>, int transit, int transitStyle, boolean always) &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.mHost == <span class="literal">null</span> &amp;&amp; <span class="keyword">new</span><span class="type">State</span> != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"No host"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(always || <span class="built_in">this</span>.mCurState != <span class="keyword">new</span><span class="type">State</span>) &#123;</div><div class="line">       ...</div><div class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.mActive.size(); ++i) &#123;</div><div class="line">                Fragment f = (Fragment)<span class="built_in">this</span>.mActive.<span class="keyword">get</span>(i);</div><div class="line">                <span class="keyword">if</span>(f != <span class="literal">null</span>) &#123;</div><div class="line">                    <span class="built_in">this</span>.moveToState(f, <span class="keyword">new</span><span class="type">State</span>, transit, transitStyle, <span class="literal">false</span>);</div><div class="line">                    <span class="keyword">if</span>(f.mLoaderManager != <span class="literal">null</span>) &#123;</div><div class="line">                        loadersRunning |= f.mLoaderManager.hasRunningLoaders();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">       ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是在mActive中取出刚刚放入的Fragment。最后调用moveToState（Fragment…）方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> moveToState(Fragment f, <span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitionStyle,</div><div class="line">        <span class="keyword">boolean</span> keepActive) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">if</span> (f.mState &lt; newState) &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">switch</span> (f.mState) &#123;</div><div class="line">            <span class="keyword">case</span> Fragment.<span class="string">INITIALIZING:</span></div><div class="line">                <span class="comment">//...</span></div><div class="line">                f.mHost = mHost;</div><div class="line">                f.mParentFragment = mParent;</div><div class="line">                f.mFragmentManager = mParent != <span class="literal">null</span></div><div class="line">                        ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();</div><div class="line">                f.mCalled = <span class="literal">false</span>;</div><div class="line">                f.onAttach(mHost.getContext());</div><div class="line">                <span class="comment">//...</span></div><div class="line">                <span class="keyword">if</span> (f.mParentFragment == <span class="literal">null</span>) &#123;</div><div class="line">                    mHost.onAttachFragment(f);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!f.mRetaining) &#123;</div><div class="line">                    f.performCreate(f.mSavedFragmentState);</div><div class="line">                &#125;</div><div class="line">                f.mRetaining = <span class="literal">false</span>;</div><div class="line">                <span class="keyword">if</span> (f.mFromLayout) &#123;</div><div class="line">                    <span class="comment">//...</span></div><div class="line">                &#125;</div><div class="line">            <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    f.mState = newState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当Fragment走到了现在，我们终于看到了mHost的赋值，同时给Fragment的创建流程也有了一定的了解了。也就是说Fragment在Attach到宿主Activity是mHost进行赋值。那么我们又回到上面说的Bug上，这里mHost运行了一段时间后，突然为空了。这让我们联想到是由于宿主Activity和Fragment失去的连接，导致了Fragment的mHost为Null。那么在开发的时候不是必现的，那么排除了这种情况是代码上的问题。还有没有其他的Activity于Fragment失联的情况了，猜想是App处在后台时，在系统内存紧张后回收掉了Activity，但是同时Fragment在做耗时操作刚好又用到了getActivity().那么悲剧就这样产生了。</p>
<p>我们来看下Activity在销毁是的代码。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">performDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    mDestroyed = <span class="keyword">true</span>;</div><div class="line">    mWindow.destroy();</div><div class="line">    mFragments.dispatchDestroy();</div><div class="line">    onDestroy();</div><div class="line">    mFragments.doLoaderDestroy();</div><div class="line">    <span class="keyword">if</span> (mVoiceInteractor != <span class="keyword">null</span>) &#123;</div><div class="line">        mVoiceInteractor.detachActivity();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到了mFragments.dispatchDestroy()方法。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="literal">void</span> dispatchDestroy() &#123;</div><div class="line">        mDestroyed = <span class="literal">true</span>;</div><div class="line">        execPendingActions();</div><div class="line">        moveToState(Fragment.INITIALIZING, <span class="literal">false</span>);</div><div class="line">        mHost = <span class="built_in">null</span>;</div><div class="line">        mContainer = <span class="built_in">null</span>;</div><div class="line">        mParent = <span class="built_in">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="literal">void</span> moveToState(Fragment f, int newState, int transit, int transitionStyle,</div><div class="line">        <span class="built_in">boolean</span> keepActive) &#123;</div><div class="line">    <span class="keyword">if</span> (f.mState &lt; newState) &#123;</div><div class="line">        <span class="params">...</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</div><div class="line">        switch (f.mState) &#123;</div><div class="line">            <span class="params">...</span></div><div class="line">            <span class="keyword">case</span> Fragment.CREATED:</div><div class="line">                <span class="keyword">if</span> (newState &lt; Fragment.CREATED) &#123;</div><div class="line">                    <span class="keyword">if</span> (mDestroyed) &#123;</div><div class="line">                        <span class="params">...</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (f.mAnimatingAway != <span class="built_in">null</span>) &#123;</div><div class="line">                        <span class="params">...</span></div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span>.v(<span class="built_in">TAG</span>, <span class="string">"movefrom CREATED: "</span> + f);</div><div class="line">                        <span class="keyword">if</span> (!f.mRetaining) &#123;</div><div class="line">                            f.performDestroy();</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            f.mState = Fragment.INITIALIZING;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        f.performDetach();</div><div class="line">                        <span class="keyword">if</span> (!keepActive) &#123;</div><div class="line">                            <span class="keyword">if</span> (!f.mRetaining) &#123;</div><div class="line">                                makeInactive(f);</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                f.mHost = <span class="built_in">null</span>;</div><div class="line">                                f.mParentFragment = <span class="built_in">null</span>;</div><div class="line">                                f.mFragmentManager = <span class="built_in">null</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="params">...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后会走到else分支中,将Fragment的mHost置空，这就导致了getActivity()NPE的出现。<br>对于这类问题是因为没有控制好Fragment于Activity失联后没有正确的取消耗时的操作，那么需要开发者在onDetach的时候及时取消掉耗时的操作。</p>
<h2 id="Fragment之replace和add的区别"><a href="#Fragment之replace和add的区别" class="headerlink" title="Fragment之replace和add的区别"></a><a href="#Fragment_u4E4Breplace_u548Cadd_u7684_u533A_u522B" title="Fragment之replace和add的区别"></a>Fragment之replace和add的区别</h2><p>Fragment的replace和add在一般情况下展现的效果是一致的,不经历一些Bug 可能用replace的人一直用replace，用add的人一直用add，那么这个Bug究竟是什么呢。其实也是在特殊时期发生的事，那就是在Activity回收后恢复时,出现了多个Fragment,当然这个Bug官方在v4-24.0.0+ 开始已经解决了，后续将不会出现这个问题。这个Bug主要产生点就是Activity销毁和恢复是状态保存机制造成的。系统在回收Activity的时候会保存Fragment的状态。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">String</span> mClassName;</div><div class="line"><span class="keyword">final</span> <span class="built_in">int</span> mIndex;</div><div class="line"><span class="keyword">final</span> <span class="built_in">boolean</span> mFromLayout;</div><div class="line"><span class="keyword">final</span> <span class="built_in">int</span> mFragmentId;</div><div class="line"><span class="keyword">final</span> <span class="built_in">int</span> mContainerId;</div><div class="line"><span class="keyword">final</span> <span class="keyword">String</span> mTag;</div><div class="line"><span class="keyword">final</span> <span class="built_in">boolean</span> mRetainInstance;</div><div class="line"><span class="keyword">final</span> <span class="built_in">boolean</span> mDetached;</div><div class="line"><span class="keyword">final</span> Bundle mArguments;</div></pre></td></tr></table></figure>
<p>24.0.0之前保存的变量如上。但是在使用addAPI是经常需要使用Hide和Show的操作，这些操作都是根据mHidden变量来控制的，在来看下以前的版本，压根就没有保存这个变量，所以在使用add去操作Fragment时会将add的多个Fragment同时显示出来，或者在onCreate里再次创建了同一个Fragment，Fragment默认的mHidden = false，这样就会造成重影的问题。在24.0.0之后，官方加入了mHidden字段。来保存Fragment显隐问题。</p>
<p>那么replace为啥没有这样的问题出现呢，而add的操作就会存在。我们来看下源码。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> FragmentTransaction <span class="built_in">add</span>(Fragment fragment, <span class="keyword">String</span> tag) &#123;</div><div class="line">    doAddOp(<span class="number">0</span>, fragment, tag, OP_ADD);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> FragmentTransaction replace(<span class="built_in">int</span> containerViewId, Fragment fragment, <span class="keyword">String</span> tag) &#123;</div><div class="line">    <span class="keyword">if</span> (containerViewId == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must use non-zero containerViewId"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    doAddOp(containerViewId, fragment, tag, OP_REPLACE);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>add和replace的不同点只是在构造Op是的cmd不一样，一个是OP_ADD，一个OP_REPLACE。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">while</span> (op != <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> enterAnim = state != <span class="literal">null</span> ? 0 : op.enterAnim;</div><div class="line">            <span class="keyword">int</span> exitAnim = state != <span class="literal">null</span> ? 0 : op.exitAnim;</div><div class="line">            <span class="keyword">switch</span> (op.cmd) &#123;</div><div class="line">                <span class="keyword">case</span> <span class="string">OP_ADD:</span> &#123;</div><div class="line">                    Fragment f = op.fragment;</div><div class="line">                    f.mNextAnim = enterAnim;</div><div class="line">                    mManager.addFragment(f, <span class="literal">false</span>);</div><div class="line">                &#125; <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">OP_REPLACE:</span> &#123;</div><div class="line">                    Fragment f = op.fragment;</div><div class="line">                    <span class="keyword">int</span> containerId = f.mContainerId;</div><div class="line">                    <span class="keyword">if</span> (mManager.mAdded != <span class="literal">null</span>) &#123;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = mManager.mAdded.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                            Fragment old = mManager.mAdded.get(i);</div><div class="line">                            <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) Log.v(TAG,</div><div class="line">                                    <span class="string">"OP_REPLACE: adding="</span> + f + <span class="string">" old="</span> + old);</div><div class="line">                            <span class="keyword">if</span> (old.mContainerId == containerId) &#123;</div><div class="line">                                <span class="keyword">if</span> (old == f) &#123;</div><div class="line">                                    op.fragment = f = <span class="literal">null</span>;</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    <span class="keyword">if</span> (op.removed == <span class="literal">null</span>) &#123;</div><div class="line">                                        op.removed = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</div><div class="line">                                    &#125;</div><div class="line">                                    op.removed.add(old);</div><div class="line">                                    old.mNextAnim = exitAnim;</div><div class="line">                                    <span class="keyword">if</span> (mAddToBackStack) &#123;</div><div class="line">                                        old.mBackStackNesting += <span class="number">1</span>;</div><div class="line">                                        <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) Log.v(TAG, <span class="string">"Bump nesting of "</span></div><div class="line">                                                + old + <span class="string">" to "</span> + old.mBackStackNesting);</div><div class="line">                                    &#125;</div><div class="line">                                    mManager.removeFragment(old, transition, transitionStyle);</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</div><div class="line">                        f.mNextAnim = enterAnim;</div><div class="line">                        mManager.addFragment(f, <span class="literal">false</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">break</span>;</div><div class="line">               ...</div><div class="line"></div><div class="line">        mManager.moveToState(mManager.mCurState, transition, transitionStyle, <span class="literal">true</span>);</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里分别对cmd的操作可以看出来add是直接添加一个Fragment，可以多个Fragment一起存在，而replace则是先remove其他Fragment在add新的Fragment。这两个API使用场景就发生了变化。<br>对于在一个Fragment只存在一个或者存在多个不易切换的Fragment适合使用replace，毕竟replace不需要耗费其他的内存来保存多个Fragment。在使用多个Fragment频繁切换时更适合add，Fragment的切换使用Hide和show来实现，这样数据不需要再次加载，即是一种空间换速度的方式，这里也可以看出来replace的时候是remove了其他的Fragment所以一般不会产生多个Fragment的同时展现。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fragment/">Fragment</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android-Binder技术之ServiceManager启动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/25/Android-Binder技术之ServiceManager启动/" class="article-date">
      <time datetime="2017-04-25T07:21:44.000Z" itemprop="datePublished">2017-04-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/25/Android-Binder技术之ServiceManager启动/">Android-Binder技术之ServiceManager启动</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>ServiceManager是用户空间的一个守护进程，是用来管理以Binder通讯的Service的大管家。ServiceManager作为Android系统中服务的管理者，具备的功能很明显也会很简单，它的功能主要是当Service启动时将服务注册进来，同时当Client端要获取Service时提供查询和获取的任务,那么作为这样的一个管理者是如何启动的呢，我们接下来说说ServiceManager的启动。</p>
</blockquote>
<h2 id="一-启动过程"><a href="#一-启动过程" class="headerlink" title="一.启动过程"></a><a href="#u4E00-_u542F_u52A8_u8FC7_u7A0B" title="一.启动过程"></a>一.启动过程</h2><p>ServiceManager作为一个大管家其实也是一个以Binder通讯的Service，但是这个特殊的Service的启动肯定是有一定的优先权的。它的初始化是在init进程去解析init.rc文件的时候。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service servicemanager /system/bin/servicemanager</div><div class="line">    class core</div><div class="line">   <span class="built_in"> user system</span></div><div class="line">   <span class="built_in"> group system</span></div><div class="line">    critical</div><div class="line">    onrestart restart healthd</div><div class="line">    onrestart restart zygote</div><div class="line">    onrestart restart media</div><div class="line">    onrestart restart surfaceflinger</div><div class="line">    onrestart restart drm</div></pre></td></tr></table></figure>
<p>ServiceManager的启动的代码是service_manager.c的main函数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></div><div class="line">    <span class="comment">//打开binder驱动，申请分配128k的内存空间</span></div><div class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">//成为上下文管理者</span></div><div class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    selinux_enabled = is_selinux_enabled(); <span class="comment">//selinux权限是否使能</span></div><div class="line">    sehandle = selinux_android_service_context_handle();</div><div class="line">    selinux_status_open(<span class="literal">true</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (selinux_enabled &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (sehandle == <span class="literal">NULL</span>) &#123;  </div><div class="line">            <span class="built_in">abort</span>(); <span class="comment">//无法获取sehandle</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (getcon(&amp;service_manager_context) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">abort</span>(); <span class="comment">//无法获取service_manager上下文</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">//进入无限循环，处理client端发来的请求</span></div><div class="line">    binder_loop(bs, svcmgr_handler);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出来ServiceManager的启动过程分成上个部分。</p>
<ol>
<li>打开Binder驱动文件，分配空间</li>
<li>调用binder_become_context_manager申请成为Binder上下文管理者</li>
<li><p>调用binder_loop进入循环等待处理客户端的请求，如果没有请求，进入睡眠，一旦有请求，立刻被唤醒，然后处理Client请求<br>我们接下来一步一步的看</p>
<h3 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a><a href="#binder_open" title="binder_open"></a>binder_open</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//frameworks/native/cmds/servicemanager/<span class="keyword">binder.c</span></div><div class="line"><span class="keyword">struct </span><span class="keyword">binder_state </span>*<span class="keyword">binder_open(size_t </span>mapsize)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct </span><span class="keyword">binder_state </span>*<span class="keyword">bs;</span></div><div class="line">    ...</div><div class="line">    //通过系统调用陷入内核，打开<span class="keyword">Binder设备驱动</span></div><div class="line">    <span class="keyword">bs-&gt;fd </span>= open(<span class="string">"/dev/binder"</span>, O_RDWR)<span class="comment">;</span></div><div class="line">    <span class="meta">if</span> (<span class="keyword">bs-&gt;fd </span>&lt; <span class="number">0</span>) &#123;</div><div class="line">        goto fail_open<span class="comment">; // 无法打开binder设备</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //通过系统调用，ioctl获取<span class="keyword">binder版本信息</span></div><div class="line">    <span class="meta">if</span> ((ioctl(<span class="keyword">bs-&gt;fd, </span><span class="keyword">BINDER_VERSION, </span>&amp;vers) == -<span class="number">1</span>) <span class="title">||</span></div><div class="line">        (vers.protocol_version != <span class="keyword">BINDER_CURRENT_PROTOCOL_VERSION)) </span>&#123;</div><div class="line">        goto fail_open<span class="comment">; //内核空间与用户空间的binder不是同一版本</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bs-&gt;mapsize </span>= mapsize<span class="comment">;</span></div><div class="line">    //通过系统调用，mmap内存映射，mmap必须是page的整数倍</div><div class="line">    <span class="keyword">bs-&gt;mapped </span>= mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, <span class="keyword">bs-&gt;fd, </span><span class="number">0</span>)<span class="comment">;</span></div><div class="line">    <span class="meta">if</span> (<span class="keyword">bs-&gt;mapped </span>== MAP_FAILED) &#123;</div><div class="line">        goto fail_map<span class="comment">; // binder设备内存无法映射</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码流程其实很清楚打开Binder驱动的具体步骤:</p>
<ol>
<li>open(“/dev/binder”, O_RDWR)进过系统调用，最后调用的是驱动的binder_open方法。这个方法会创建一个binder_proc对象，并将这个对象存入全局变量binder_procs中。</li>
<li>mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0)经过系统调用，最后调用的是驱动的binder_mmap方法，这个方法是用来创建一个内存映射以为后边处理请求提供内存。第一个参数表示映射内存的起始地址，Null表示由系统决定，mapsize为映射的内存大小，值为128k，PROT_READ表示映射空间是可读的，MAP_PRIVATE表示进程在写入内存时是写入到内存的拷贝里。 bs-&gt;fd是“/dev/binder”的句柄，0是代表偏移量。该方法会创建一个Binder_buffer对象并保存在binder_proc中。</li>
<li><p>binder_state是用来保存/dev/binder驱动信息的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> fd; <span class="comment">// dev/binder的文件描述符</span></div><div class="line">    <span class="keyword">void</span> *mapped; <span class="comment">//指向mmap的内存地址</span></div><div class="line">    <span class="keyword">size_t</span> mapsize; <span class="comment">//分配的内存大小，默认为128KB</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>那么这里说的到系统调用是如何进行的呢。我们来具体看下open(“/dev/binder”)</p>
<h4 id="open-“-dev-binder”"><a href="#open-“-dev-binder”" class="headerlink" title="open(“/dev/binder”)"></a><a href="#open_28_u201C/dev/binder_u201D_29" title="open(“/dev/binder”)"></a>open(“/dev/binder”)</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//drivers/staging/<span class="keyword">android/binder.c</span></div><div class="line"><span class="symbol">static</span> const <span class="keyword">struct </span>file_operations <span class="keyword">binder_fops </span>= &#123;</div><div class="line"><span class="symbol">.owner</span> = THIS_MODULE,</div><div class="line"><span class="symbol">.poll</span> = <span class="keyword">binder_poll,</span></div><div class="line"><span class="symbol">.unlocked_ioctl</span> = <span class="keyword">binder_ioctl,</span></div><div class="line"><span class="symbol">.mmap</span> = <span class="keyword">binder_mmap,</span></div><div class="line"><span class="symbol">.open</span> = <span class="keyword">binder_open,</span></div><div class="line"><span class="symbol">.flush</span> = <span class="keyword">binder_flush,</span></div><div class="line"><span class="symbol">.release</span> = <span class="keyword">binder_release,</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="symbol">static</span> <span class="keyword">struct </span>miscdevice <span class="keyword">binder_miscdev </span>= &#123;</div><div class="line"><span class="symbol">.minor</span> = MISC_DYNAMIC_MINOR,</div><div class="line"><span class="symbol">.name</span> = <span class="string">"binder"</span>,</div><div class="line"><span class="symbol">.fops</span> = &amp;<span class="keyword">binder_fops</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="symbol">static</span> int __init <span class="keyword">binder_init(void)</span></div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    ret = misc_register(&amp;<span class="keyword">binder_miscdev);</span></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="symbol">device_initcall</span>(<span class="keyword">binder_init);</span></div></pre></td></tr></table></figure>
<ol>
<li>device_initcall(binder_init)的作用是将函数binder_init注册到Kernel的初始化函数中,这样的话当内核在启动的时候将会以一定的顺序去执行这些初始化函数，也就是说在Kernel启动的时候就回去调用binder_init方法。</li>
<li>binder_init的方法是将Binder驱动注册到文件系统中，这样就可以通过操作文件来调用驱动，该文件的节点的“/dev/binder”设备信息是binder_miscdev</li>
<li>对于结构体binder_miscdev我们需要关心的是fops，这个变量代表的是文件操作的对象，也就是binder_fops。</li>
<li>binder_fops结构体中定义的变量owner是标明了该文件操作变量的拥有者，就是该驱动；poll则指定了poll函数指针，当我们对/dev/binder文件节点执行poll()操作时，实际上就是调用的binder_poll()函数；同理，mmap()对应binder_mmap()，open()对应binder_open()，ioctl()对应binder_ioctl()…</li>
</ol>
<p>经过上面的介绍，我们可以知道open(“/dev/binder”, O_RDWR)实际上是调用Binder驱动中的binder函数。<br>static HLIST_HEAD(binder_procs);<br>…</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> int binder_open(<span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span> *nodp, <span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *filp)</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *<span class="keyword">proc</span>;</div><div class="line"></div><div class="line">    binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">"binder_open: %d:%d\n"</span>,</div><div class="line">        current-&gt;group_leader-&gt;pid, current-&gt;pid);</div><div class="line"></div><div class="line">    <span class="comment">// 为proc分配内存</span></div><div class="line">    <span class="keyword">proc</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="keyword">proc</span>), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">proc</span> == NULL)</div><div class="line">    <span class="keyword">return</span> -ENOMEM;</div><div class="line">    get_task_struct(current);</div><div class="line">    <span class="comment">// 将proc-&gt;tsk指向当前线程</span></div><div class="line">    <span class="keyword">proc</span>-&gt;tsk = current;</div><div class="line">    <span class="comment">// 初始化proc的待处理事务列表</span></div><div class="line">    INIT_LIST_HEAD(&amp;<span class="keyword">proc</span>-&gt;todo);</div><div class="line">    <span class="comment">// 初始化proc的等待队列</span></div><div class="line">    init_waitqueue_head(&amp;<span class="keyword">proc</span>-&gt;wait);</div><div class="line">    <span class="comment">// 设置proc的进程优先级为当前线程的优先级</span></div><div class="line">    <span class="keyword">proc</span>-&gt;default_priority = task_nice(current);</div><div class="line"></div><div class="line">    binder_lock(__func__);</div><div class="line"></div><div class="line">    binder_stats_created(BINDER_STAT_PROC);</div><div class="line">    <span class="comment">// 将该进程上下文信息proc保存到"全局哈希表binder_procs"中</span></div><div class="line">    hlist_add_head(&amp;<span class="keyword">proc</span>-&gt;proc_node, &amp;binder_procs);</div><div class="line">    <span class="comment">// 设置进程id</span></div><div class="line">    <span class="keyword">proc</span>-&gt;pid = current-&gt;group_leader-&gt;pid;</div><div class="line">    INIT_LIST_HEAD(&amp;<span class="keyword">proc</span>-&gt;delivered_death);</div><div class="line">    <span class="comment">// 将proc添加到私有数据中。</span></div><div class="line">    <span class="comment">// 这样，mmap(),ioctl()等函数都可以通过私有数据获取到proc，即该进程的上下文信息</span></div><div class="line">    filp-&gt;private_data = <span class="keyword">proc</span>;</div><div class="line"></div><div class="line">    binder_unlock(__func__);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</div><div class="line">    <span class="built_in">char</span> strbuf[<span class="number">11</span>];</div><div class="line">    snprintf(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, <span class="keyword">proc</span>-&gt;pid);</div><div class="line">    <span class="keyword">proc</span>-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,</div><div class="line">        binder_debugfs_dir_entry_proc, <span class="keyword">proc</span>, &amp;binder_proc_fops);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么在上面我们提到了binder_open()函数会生成binder_proc对象，这个对象是用来保存当前进程的信息的。</p>
<ol>
<li>创建并初始化binder_proc结构体变量proc。binder_proc是描述Binder进程的上下文信息结构体。这里，就是将ServiceManager这个进程的信息都存储到proc中</li>
<li>将proc添加到全局哈希表binder_procs中</li>
<li>将proc设为filp的私有成员。这样，在mmap()，ioctl()等函数中，我们都可以根据filp的私有成员来获取proc信息。</li>
</ol>
<p>说完Open我们在看看mmap函数，他对应的系统调用时binder_mmap</p>
<h4 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a><a href="#binder_mmap" title="binder_mmap"></a>binder_mmap</h4><p>这个函数主要的作用是创建内存映射，这里就要说到Binder IPC通信方法对内存是如何操作的了，Android为什么要使用Binder来作为大多数IPC通信的主要手段呢。我们知道在Linux系统将应用的内存地址划分为2个部分，0-3G为用户空间，也就是我们App运行的地方，4-5G为内核空间，也就是Kernel和驱动运行的地方，如果需要进行两块内存通信时，也就是用户空间的进程和内核空间中的进程进行IPC通信时是如何操作的呢，我们知道Linux的IPC通信手段有很多，比如管道，消息队列，socket，内存共享等等。但是Android系统大多都是没有使用这些手段。内存控制比较复杂，对于Android系统来说不是合适的。socket是比较常用于网络中，剩下的我看下Android为什么没有使用管道或者消息队列，原因是这两个手段要完成一次IPC通信的话需要进行两次拷贝，第一次将数据从用户空间拷贝到内核空间，第二次是将内核空间的数据拷贝到相对应的进程中，这样的两次拷贝对于移动设备来说是一个很大的消耗，于是针对Android运行的设备进行优化，产生了Binder通信机制，只需要进行一次数据的拷贝，因为内核空间和目标进程的空间共同指向了一块物理内存，这样就不需要在内核空间进行再一次的数据拷贝了。那么binder_mmap所做的事情就是映射同一片物理内存。</p>
<p>至此，binder_open(128*1024)算是介绍完了。从”用户空间的ServiceManager进程” 和 “Binder驱动”这两个方面分析它的作用。<br>(01) ServiceManager进程：就是打开/dev/binder，同时映射物理内存到进程空间。<br>(02) Binder驱动：新建并初始化该进程对应的binder_proc结构体，同时将内核虚拟地址和该进程的虚拟地址映射到同一物理内存中。</p>
<h3 id="binder-become-context-manager"><a href="#binder-become-context-manager" class="headerlink" title="binder_become_context_manager()"></a><a href="#binder_become_context_manager_28_29" title="binder_become_context_manager()"></a>binder_become_context_manager()</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int <span class="keyword">binder_become_context_manager(struct </span><span class="keyword">binder_state </span>*<span class="keyword">bs)</span></div><div class="line">&#123;</div><div class="line">    return ioctl(<span class="keyword">bs-&gt;fd, </span><span class="keyword">BINDER_SET_CONTEXT_MGR, </span><span class="number">0</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ioctl通过系统调用，最后调用的是binder_ioctl</p>
<h4 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a><a href="#binder_ioctl" title="binder_ioctl"></a>binder_ioctl</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局binder实体，准确点说是ServiceManager的binder实体</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">binder_context_mgr_node</span>;</span></div><div class="line"><span class="comment">// ServiceManager守护进程的uid</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">uid_t</span> binder_context_mgr_uid = <span class="number">-1</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> binder_stop_on_user_error;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> ret;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line"><span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line"></div><div class="line"><span class="comment">// 中断等待函数。</span></div><div class="line"><span class="comment">// 1\. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。</span></div><div class="line"><span class="comment">// 2\. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。</span></div><div class="line"><span class="comment">//    当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时；</span></div><div class="line"><span class="comment">//    则继续执行；否则，再进入等待状态。</span></div><div class="line">ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">...</div><div class="line"></div><div class="line">binder_lock(__func__);</div><div class="line"><span class="comment">// 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></div><div class="line">thread = binder_get_thread(proc);</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">switch</span> (cmd) &#123;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (binder_context_mgr_uid != <span class="number">-1</span>) &#123;</div><div class="line">        ...</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        <span class="comment">// 设置ServiceManager对应的uid</span></div><div class="line">        binder_context_mgr_uid = current-&gt;cred-&gt;euid;</div><div class="line"></div><div class="line">    <span class="comment">// 新建binder实体，并将proc进程上下文信息保存到binder实体中；</span></div><div class="line">    <span class="comment">// 然后，将该binder实体赋值给全局变量binder_context_mgr_node。</span></div><div class="line">    <span class="comment">// 这个全局的binder实体，是ServiceManager对应的binder实体。</span></div><div class="line">    binder_context_mgr_node = binder_new_node(proc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 设置binder实体的引用计数等参数</span></div><div class="line">    binder_context_mgr_node-&gt;local_weak_refs++;</div><div class="line">    binder_context_mgr_node-&gt;local_strong_refs++;</div><div class="line">    binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</div><div class="line">    binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">...</div><div class="line"></div><div class="line">&#125;</div><div class="line">ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">err:</div><div class="line"><span class="comment">// 去掉thread的BINDER_LOOPER_STATE_NEED_RETURN标记</span></div><div class="line"><span class="keyword">if</span> (thread)</div><div class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</div><div class="line">binder_unlock(__func__);</div><div class="line">wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>调用wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2)。由于binder_stop_on_user_error是全局变量，它的初始值是0，因此binder_stop_on_user_error &lt; 2为true，不进入中断等待，而是直接跳过该函数继续运行</li>
<li>binder_get_thread()会在proc中查找当前线程对应的binder_thread结构体；由于之前还未创建该线程的binder_thread结构体，因此查找失败。进而创建一个binder_thread结构体变量，并将其添加到proc-&gt;threads红黑树中，然后返回该变量</li>
<li>cmd的值是我们调用ioctl()传入的参数BINDER_SET_CONTEXT_MGR。在BINDER_SET_CONTEXT_MGR分支中，会设置binder_context_mgr_uid，binder_context_mgr_uid是一个全局变量，它代表ServiceManager对应的uid；接着，通过binder_new_node()新建一个Binder实体(即binder_node结构体对象)，并将该Binder实体赋值给全局变量binder_context_mgr_node，binder_context_mgr_node就是Serveice Manager对应的Binder实体；最后，设置binder实体的引用计数等参数。</li>
<li>清除thread-&gt;looper的BINDER_LOOPER_STATE_NEED_RETURN标记。这个BINDER_LOOPER_STATE_NEED_RETURN标记，是在调用binder_get_thread()中创建binder_thread对象时添加的。</li>
</ol>
<p>至此，binder_become_context_manager()就介绍完了。它的作用：</p>
<ol>
<li>ServiceManager进程：告诉Kernel驱动，当前进程(即ServiceManager进程)是Binder上下文管理者。</li>
<li>Binder驱动：新建当前线程对应的binder_thread对象，并将其添加到进程上下文信息binder_proc的threads红黑树中；新建ServiceManager对应的binder实体，并将该binder实体保存到全局变量binder_context_mgr_node中。</li>
</ol>
<h3 id="binder-loop"><a href="#binder-loop" class="headerlink" title="binder_loop()"></a><a href="#binder_loop_28_29" title="binder_loop()"></a>binder_loop()</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">void</span> <span class="keyword">binder_loop(struct </span><span class="keyword">binder_state </span>*<span class="keyword">bs, </span><span class="keyword">binder_handler </span>func)</div><div class="line">&#123;</div><div class="line">    int res<span class="comment">; </span></div><div class="line">    <span class="keyword">struct </span><span class="keyword">binder_write_read </span><span class="keyword">bwr;</span></div><div class="line">    unsigned readbuf[<span class="number">32</span>]<span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="keyword">bwr.write_size </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">    <span class="keyword">bwr.write_consumed </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">    <span class="keyword">bwr.write_buffer </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line"></div><div class="line">    // 告诉Kernel，ServiceManager进程进入了消息循环状态。</div><div class="line">    readbuf[<span class="number">0</span>] = <span class="keyword">BC_ENTER_LOOPER;</span></div><div class="line">    <span class="keyword">binder_write(bs, </span>readbuf, sizeof(unsigned))<span class="comment">;</span></div><div class="line"></div><div class="line">    for (<span class="comment">;;) &#123;</span></div><div class="line">        <span class="keyword">bwr.read_size </span>= sizeof(readbuf)<span class="comment">;</span></div><div class="line">        <span class="keyword">bwr.read_consumed </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">        <span class="keyword">bwr.read_buffer </span>= (unsigned) readbuf<span class="comment">;</span></div><div class="line"></div><div class="line">        // 向Kernel中发送消息(先写后读)。</div><div class="line">        // 先将消息传递给Kernel，然后再从Kernel读取消息反馈</div><div class="line">        res = ioctl(<span class="keyword">bs-&gt;fd, </span><span class="keyword">BINDER_WRITE_READ, </span>&amp;<span class="keyword">bwr);</span></div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        // 解析读取的消息反馈</div><div class="line">        res = <span class="keyword">binder_parse(bs, </span><span class="number">0</span>, readbuf, <span class="keyword">bwr.read_consumed, </span>func)<span class="comment">;</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的作用就是告诉KernelServiceManager将进入循环等待处理请求的状态，接着调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)进入循环状态，等待Client端的请求。</p>
<h4 id="binder-write"><a href="#binder-write" class="headerlink" title="binder_write()"></a><a href="#binder_write_28_29" title="binder_write()"></a>binder_write()</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int <span class="keyword">binder_write(struct </span><span class="keyword">binder_state </span>*<span class="keyword">bs, </span>void *data, unsigned len)</div><div class="line">&#123;</div><div class="line">    struct <span class="keyword">binder_write_read </span><span class="keyword">bwr;</span></div><div class="line">    int res<span class="comment">;</span></div><div class="line">    <span class="keyword">bwr.write_size </span>= len<span class="comment">;                // 数据长度</span></div><div class="line">    <span class="keyword">bwr.write_consumed </span>= <span class="number">0</span><span class="comment">;             </span></div><div class="line">    <span class="keyword">bwr.write_buffer </span>= (unsigned) data<span class="comment">;  // 数据是BINDER_WRITE_READ</span></div><div class="line">    <span class="keyword">bwr.read_size </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">    <span class="keyword">bwr.read_consumed </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">    <span class="keyword">bwr.read_buffer </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">    res = ioctl(<span class="keyword">bs-&gt;fd, </span><span class="keyword">BINDER_WRITE_READ, </span>&amp;<span class="keyword">bwr);</span></div><div class="line">    if (res &lt; <span class="number">0</span>) &#123;</div><div class="line">        fprintf(stderr,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</div><div class="line">                strerror(errno))<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    return res<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的ioctl并没有要去读取返回的信息。我们来看下ioctl在执行BINDER_WRITE_READ是的代码</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">static</span> long <span class="keyword">binder_ioctl(struct </span>file *filp, unsigned int cmd, unsigned long arg)</div><div class="line">&#123;</div><div class="line"><span class="symbol">int</span> ret<span class="comment">;</span></div><div class="line"><span class="keyword">struct </span><span class="keyword">binder_proc </span>*<span class="meta">proc</span> = filp-&gt;private_data<span class="comment">;</span></div><div class="line"><span class="keyword">struct </span><span class="keyword">binder_thread </span>*thread<span class="comment">;</span></div><div class="line"><span class="symbol">unsigned</span> int size = _IOC_SIZE(cmd)<span class="comment">;</span></div><div class="line"><span class="symbol">void</span> __user *ubuf = (void __user *)arg<span class="comment">;</span></div><div class="line"></div><div class="line">// 中断等待函数。</div><div class="line">// <span class="number">1</span>\. 当<span class="keyword">binder_stop_on_user_error </span>&lt; <span class="number">2</span>为true时；不会进入等待状态；直接跳过。</div><div class="line">// <span class="number">2</span>\. 当<span class="keyword">binder_stop_on_user_error </span>&lt; <span class="number">2</span>为false时，进入等待状态。</div><div class="line">//    当有其他进程通过wake_up_interruptible来唤醒<span class="keyword">binder_user_error_wait队列，并且binder_stop_on_user_error </span>&lt; <span class="number">2</span>为true时；</div><div class="line">//    则继续执行；否则，再进入等待状态。</div><div class="line"><span class="symbol">ret</span> = wait_event_interruptible(<span class="keyword">binder_user_error_wait, </span><span class="keyword">binder_stop_on_user_error </span>&lt; <span class="number">2</span>)<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="keyword">binder_lock(__func__);</span></div><div class="line">// 在<span class="meta">proc</span>进程中查找该线程对应的<span class="keyword">binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></div><div class="line"><span class="symbol">thread</span> = <span class="keyword">binder_get_thread(proc);</span></div><div class="line"><span class="symbol">...</span></div><div class="line"></div><div class="line"><span class="keyword">switch </span>(cmd) &#123;</div><div class="line"><span class="symbol">case</span> <span class="keyword">BINDER_WRITE_READ: </span>&#123;</div><div class="line">    <span class="keyword">struct </span><span class="keyword">binder_write_read </span><span class="keyword">bwr;</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    // 将<span class="keyword">binder_write_read从"用户空间" </span>拷贝到 <span class="string">"内核空间"</span></div><div class="line">    <span class="meta">if</span> (copy_from_user(&amp;<span class="keyword">bwr, </span>ubuf, sizeof(<span class="keyword">bwr))) </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果write_size&gt;<span class="number">0</span>，则进行写操作</div><div class="line">    <span class="meta">if</span> (<span class="keyword">bwr.write_size </span>&gt; <span class="number">0</span>) &#123;</div><div class="line">        ret = <span class="keyword">binder_thread_write(proc, </span>thread, (void __user *)<span class="keyword">bwr.write_buffer, </span><span class="keyword">bwr.write_size, </span>&amp;<span class="keyword">bwr.write_consumed);</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果read_size&gt;<span class="number">0</span>，则进行读操作</div><div class="line">    <span class="meta">if</span> (<span class="keyword">bwr.read_size </span>&gt; <span class="number">0</span>) &#123;</div><div class="line">        ret = <span class="keyword">binder_thread_read(proc, </span>thread, (void __user *)<span class="keyword">bwr.read_buffer, </span><span class="keyword">bwr.read_size, </span>&amp;<span class="keyword">bwr.read_consumed, </span>filp-&gt;f_flags   &amp; O_NONBLOCK)<span class="comment">;</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">if</span> (copy_to_user(ubuf, &amp;<span class="keyword">bwr, </span>sizeof(<span class="keyword">bwr))) </span>&#123;</div><div class="line">        ret = -EFAULT<span class="comment">;</span></div><div class="line">        goto err<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break;</span></div><div class="line">&#125;</div><div class="line"><span class="symbol">...</span></div><div class="line">&#125;</div><div class="line"><span class="symbol">ret</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line"></div><div class="line"><span class="symbol">...</span></div><div class="line"><span class="symbol">return</span> ret<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>不进行wait_event_interruptible中断函数，往下执行</li>
<li>获取保存在proc中的thread，由于上次已经创建过thread，所以这次直接返回该对象</li>
<li>将用户数据拷贝到内核空间，这里就是将写入的数据bwr拷贝到binder驱动中</li>
<li>在binder_write()中，bwr.write_size &gt; 0 所以调用binder_thread_write函数</li>
<li>在binder_write()中，bwr.read_size =0 所以不调用binder_thread_read函数</li>
<li>将内核数据再拷贝到用户空间</li>
</ol>
<h4 id="binder-thread-write"><a href="#binder-thread-write" class="headerlink" title="binder_thread_write()"></a><a href="#binder_thread_write_28_29" title="binder_thread_write()"></a>binder_thread_write()</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,</div><div class="line">        <span class="keyword">void</span> __user *<span class="built_in">buffer</span>, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</div><div class="line">&#123;</div><div class="line">uint32_t cmd;</div><div class="line"><span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</div><div class="line"><span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</div><div class="line"></div><div class="line"><span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></div><div class="line"><span class="comment">// 每次读取32bit(即4个字节)</span></div><div class="line"><span class="built_in">while</span> (ptr &lt; <span class="built_in">end</span> &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</div><div class="line">    <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></div><div class="line">    <span class="built_in">if</span> (get_user(cmd, (uint32_t __user *)ptr))</div><div class="line">        <span class="built_in">return</span> -EFAULT;</div><div class="line"></div><div class="line">    ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">    ...</div><div class="line">    <span class="built_in">switch</span> (cmd) &#123;</div><div class="line">    ...</div><div class="line">    <span class="built_in">case</span> BC_ENTER_LOOPER:</div><div class="line">        ...</div><div class="line">        <span class="comment">// 设置线程的状态为BINDER_LOOPER_STATE_ENTERED；</span></div><div class="line">        <span class="comment">// 即，进入了循环状态</span></div><div class="line">        thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</div><div class="line">        <span class="built_in">break</span>;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新bwr.write_consumed的值</span></div><div class="line">    *consumed = ptr - <span class="built_in">buffer</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>binder_thread_write()从brw.write_buffer中读取4个字节作为cmd。这4个字节就是ServiceManager传递的指令BC_ENTER_LOOPER。<br>在BC_ENTER_LOOPER对应的switch分支中，就是将BINDER_LOOPER_STATE_ENTERED加入到thread-&gt;looper中。即，告诉Binder驱动，ServiceManager进程进入了消息循环状态。</p>
<h4 id="for"><a href="#for" class="headerlink" title="for(;;)"></a><a href="#for_28_3B_3B_29" title="for(;;)"></a>for(;;)</h4><p>进入循环后，首先调用ioctl(,BINDER_WRITE_READ,)；此时，对应的bwr内容如下：<br>bwr.write_size = 0;<br>bwr.write_consumed = 0;<br>bwr.write_buffer = 0;<br>bwr.read_size = sizeof(readbuf);<br>bwr.read_consumed = 0;<br>bwr.read_buffer = (unsigned) readbuf;</p>
<p>同样的将进入binder_ioctl函数，但是和上面的bwr不同这次数要读取，那么就会进入binder_thread_read方法</p>
<h4 id="binder-thread-read"><a href="#binder-thread-read" class="headerlink" title="binder_thread_read()"></a><a href="#binder_thread_read_28_29" title="binder_thread_read()"></a>binder_thread_read()</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">static</span> int binder_thread_read(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *<span class="keyword">proc</span>,</div><div class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span></span> *thread,</div><div class="line">                        void  __user *buffer, int size,</div><div class="line">                        signed long *consumed, int non_block)</div><div class="line">        &#123;</div><div class="line">        void __user *ptr = buffer + *consumed;</div><div class="line">        void __user *end = buffer + size;</div><div class="line"></div><div class="line">        int ret = <span class="number">0</span>;</div><div class="line">        int wait_for_proc_work;</div><div class="line"></div><div class="line">        <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></div><div class="line">        <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (put_user(BR_NOOP, (uint32_t __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            <span class="comment">// 修改指针位置</span></div><div class="line">            ptr += <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        retry:</div><div class="line">        <span class="comment">// 等待proc进程的事务标记。</span></div><div class="line">        <span class="comment">// 当线程的事务栈为空 并且 待处理事务列表为空时，该标记位true。</span></div><div class="line">        wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;</div><div class="line">                    list_empty(&amp;thread-&gt;todo);</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// 设置线程为"等待状态"</span></div><div class="line">        thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</div><div class="line">        <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">            <span class="keyword">proc</span>-&gt;ready_threads++;</div><div class="line"></div><div class="line">        ...</div><div class="line">        <span class="keyword">if</span> (wait_for_proc_work) &#123;</div><div class="line">            ...</div><div class="line">            <span class="comment">// 设置当前线程的优先级=proc-&gt;default_priority。</span></div><div class="line">            <span class="comment">// 即，当前线程要处理proc的事务，所以设置优先级和proc一样。</span></div><div class="line">            binder_set_nice(<span class="keyword">proc</span>-&gt;default_priority);</div><div class="line">            <span class="keyword">if</span> (non_block) &#123;</div><div class="line">                <span class="comment">// 非阻塞式的读取，则通过binder_has_proc_work()读取proc的事务；</span></div><div class="line">                <span class="comment">// 若没有，则直接返回</span></div><div class="line">                <span class="keyword">if</span> (!binder_has_proc_work(<span class="keyword">proc</span>, thread))</div><div class="line">                    ret = -EAGAIN;</div><div class="line">            &#125; <span class="keyword">else</span></div><div class="line">                <span class="comment">// 阻塞式的读取，则阻塞等待事务的发生。</span></div><div class="line">                ret = wait_event_interruptible_exclusive(<span class="keyword">proc</span>-&gt;wait, binder_has_proc_work(<span class="keyword">proc</span>, thread));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line"><span class="number">1</span>\. consumed为<span class="number">0</span>将会拷贝BR_NOOP到用户空间的read_buffer缓存区</div><div class="line"><span class="number">2</span>\. 目前为止，并没有进程将事务添加到当前线程中；因此，线程的事务栈和待处理事务队列都是为空。于是得到wait_for_proc_work的值是<span class="literal">true</span></div><div class="line"><span class="number">3</span>\. binder_set_nice()的作用是设置当前线程的优先级=<span class="keyword">proc</span>-&gt;default_priority</div><div class="line"><span class="number">4</span>\. 根据上下文，可知non_block为<span class="literal">false</span>。因此调用wait_event_interruptible_exclusive(<span class="keyword">proc</span>-&gt;wait, binder_has_proc_work(<span class="keyword">proc</span>, thread))。 而目前ServiceManager进程中没有待处理事务，因此binder_has_proc_work(<span class="keyword">proc</span>, thread)为<span class="literal">false</span>。从而当前线程进入中断等待状态，等待其它进程将ServiceManager唤醒</div><div class="line"></div><div class="line">到此ServiceManager进入循环等待Client请求状态。</div></pre></td></tr></table></figure>
<h2 id="二-时序图"><a href="#二-时序图" class="headerlink" title="二.时序图"></a><a href="#u4E8C-_u65F6_u5E8F_u56FE" title="二.时序图"></a>二.时序图</h2><p><img src="http://jokero1o.github.io/images/blog_servicemanager_1.png" alt=""></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ServiceManager/">ServiceManager</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 Joker Mei
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>